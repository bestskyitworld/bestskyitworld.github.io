<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="true">
  <meta name="baidu-site-verification" content="true">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bestsky.cloud","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇博客将以下图详细介绍线程。">
<meta property="og:type" content="article">
<meta property="og:title" content="专题-线程">
<meta property="og:url" content="https://bestsky.cloud/2022/02/25/%E4%B8%93%E9%A2%98-%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="全世界最好的Sky">
<meta property="og:description" content="这篇博客将以下图详细介绍线程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bestsky.cloud/2022/02/25/%E4%B8%93%E9%A2%98-%E7%BA%BF%E7%A8%8B/image-20220208170701555.png">
<meta property="og:image" content="https://bestsky.cloud/2022/02/25/%E4%B8%93%E9%A2%98-%E7%BA%BF%E7%A8%8B/image-20220208150753566.png">
<meta property="og:image" content="https://bestsky.cloud/2022/02/25/%E4%B8%93%E9%A2%98-%E7%BA%BF%E7%A8%8B/image-20220208170155879.png">
<meta property="og:image" content="https://bestsky.cloud/2022/02/25/%E4%B8%93%E9%A2%98-%E7%BA%BF%E7%A8%8B/image-20220208170346962.png">
<meta property="og:image" content="https://bestsky.cloud/2022/02/25/%E4%B8%93%E9%A2%98-%E7%BA%BF%E7%A8%8B/image-20220208180003529.png">
<meta property="article:published_time" content="2022-02-25T05:36:38.000Z">
<meta property="article:modified_time" content="2022-02-08T12:43:50.078Z">
<meta property="article:author" content="BestSkyITWorld">
<meta property="article:tag" content="JavaSE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bestsky.cloud/2022/02/25/%E4%B8%93%E9%A2%98-%E7%BA%BF%E7%A8%8B/image-20220208170701555.png">

<link rel="canonical" href="https://bestsky.cloud/2022/02/25/%E4%B8%93%E9%A2%98-%E7%BA%BF%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>专题-线程 | 全世界最好的Sky</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="全世界最好的Sky" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">全世界最好的Sky</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">人生本就孤独，你要活得有趣</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-life">

    <a href="/life/" rel="section"><i class="fa fa-coffee fa-fw"></i>人生啊</a>

  </li>
        <li class="menu-item menu-item-zatan">

    <a href="/zatan/" rel="section"><i class="fa fa-comment fa-fw"></i>杂谈</a>

  </li>
        <li class="menu-item menu-item-study">

    <a href="/study/" rel="section"><i class="fa fa-graduation-cap fa-fw"></i>学习之道</a>

  </li>
        <li class="menu-item menu-item-zhuanti">

    <a href="/zhuanti/" rel="section"><i class="fa fa-folder fa-fw"></i>专题</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bestsky.cloud/2022/02/25/%E4%B8%93%E9%A2%98-%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="BestSkyITWorld">
      <meta itemprop="description" content="专于技术，不止于技术">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="全世界最好的Sky">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          专题-线程
        </h1>

        <div class="post-meta">
		
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-25 13:36:38" itemprop="dateCreated datePublished" datetime="2022-02-25T13:36:38+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-08 20:43:50" itemprop="dateModified" datetime="2022-02-08T20:43:50+08:00">2022-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇博客将以下图详细介绍线程。</p>
<p><img src="/2022/02/25/%E4%B8%93%E9%A2%98-%E7%BA%BF%E7%A8%8B/image-20220208170701555.png" alt="image-20220208170701555"></p>
<a id="more"></a>
<h2 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h2><p>通俗来讲，进程就是一个软件（应用程序），而线程就是一个进程中的一个个更小的执行单元。这就好比一个公司是一个进程，而公司中各个部门就是线程。需要注意的是，各个进程之间资源不共享，但是一个进程中的各个线程可以共享相同资源。在Java中，线程之间共享堆内存和方法区，但是各个栈内存相互独立，一个线程一个栈。</p>
<h2 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h2><p>所谓多线程并发就是多个线程启动后，每个线程之间互相独立，各自执行其代码，这就是并发的概念。</p>
<h2 id="实现线程的三种方式"><a href="#实现线程的三种方式" class="headerlink" title="实现线程的三种方式"></a>实现线程的三种方式</h2><h3 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h3><p>编写一个类，直接继承Thread类，重写其run方法，接着在main方法中创建该对象，调用start方法就启动了该线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread01 myThread = <span class="keyword">new</span> MyThread01();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread01</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Another Thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h3><p>编写一个类，实现Runnable接口，接着实现其run方法，在main方法中创建一个Thread对象，在创建的对象的时候将编写好的类以对象的形式传给Thread对象的构造方法，接着调用Thread对象的start方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread02());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread02</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Another Thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="以上两种方法有何区别"><a href="#以上两种方法有何区别" class="headerlink" title="以上两种方法有何区别"></a>以上两种方法有何区别</h3><p>一般来说，更推荐第二种方式实现多线程，虽然先比较第一种比较麻烦，但是使用接口的方式实现多线程，那么我们还可以用该类继续去继承其他类，代码可拓展性更强，符合面向接口编程的思想。</p>
<p>另外，由于Runnable是一个接口，那么我们在创建Thread对象的时候，可以直接使用匿名内部类的方式去实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Another Thread"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h3><p>这种实现方式是JDK1.8的新特性。使用该方法实现多线程，可以获取线程的返回值。</p>
<p>第一步：创建FutureTask对象<img src="/2022/02/25/%E4%B8%93%E9%A2%98-%E7%BA%BF%E7%A8%8B/image-20220208150753566.png" alt="image-20220208150753566"></p>
<p>该对象的构造方法可以使用两个参数，一个是Runnable接口的实现类，另个是Callable接口的实现类，如果使用Callable可以获取线程的返回值，使用Runnable则不能。</p>
<p>这里我们为了方便，直接使用匿名内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FutureTask futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>接着创建Thread对象，将FutureTask对象传给其构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么如果想要获取该线程的执行结果，直接调用FutureTask类的get方法即可。</p>
<p>需要注意的是，由于get方法是在主线程中执行的，也就是说，get方法不执行完毕，主线程就没法继续往下执行，所以会使主线程受阻。</p>
<p>完整的程序如下，执行结果为3</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object o = futureTask.get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程是如何运行的"><a href="#线程是如何运行的" class="headerlink" title="线程是如何运行的"></a>线程是如何运行的</h2><h3 id="run方法和start方法的区别"><a href="#run方法和start方法的区别" class="headerlink" title="run方法和start方法的区别"></a>run方法和start方法的区别</h3><p>run方法中的代码即为线程的执行代码，run方法结束，也就意味中该线程执行结束。而start方法的作用是，在JVM中的栈内存中，开辟一个新的栈空间给该线程，start方法执行后会自动执行run方法，也就是说run方法会被压到该栈空间的栈底，和main方法是同级的。</p>
<p>需要注意的是，如果创建完一个线程对象后，直接调用其run方法，而不是start方法，那么就不能实现多线程并发，因为该方法是在主栈中被压栈，和main方法在同一个栈，所以并不是多线程。</p>
<h3 id="多线程并发并不是真正的并发"><a href="#多线程并发并不是真正的并发" class="headerlink" title="多线程并发并不是真正的并发"></a>多线程并发并不是真正的并发</h3><p>其实java程序在运行多线程的时候，看似是多个线程同时并发运行，实际上并且有，其实是多个线程之间来回切换进行执行，由于cpu的执行速度非常快，所以造成了一种错觉，让人觉得是多个线程同时在执行。</p>
<p>一个线程进入到运行状态的前提是需要抢占到cpu的时间片，比如一个线程抢到了0.2秒，那么这个线程就会执行0.2秒，之后该线程重新进入到就绪状态，跟所有的线程继续抢夺cpu的时间片，注意，抢夺时间片的这段时间里，线程并不是受阻塞状态，而是就绪状态，之后的线程生命周期会详细说明。</p>
<p>所以多线程并发并不是真正意义上的并发，而是多个线程各自抢夺执行权，进行随机的轮换执行。</p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="/2022/02/25/%E4%B8%93%E9%A2%98-%E7%BA%BF%E7%A8%8B/image-20220208170155879.png" alt="image-20220208170155879"></p>
<p><img src="/2022/02/25/%E4%B8%93%E9%A2%98-%E7%BA%BF%E7%A8%8B/image-20220208170346962.png" alt="image-20220208170346962"></p>
<p>tip:锁池并不是一个状态。</p>
<h2 id="线程的几个常用方法"><a href="#线程的几个常用方法" class="headerlink" title="线程的几个常用方法"></a>线程的几个常用方法</h2><h3 id="获取当前的线程对象"><a href="#获取当前的线程对象" class="headerlink" title="获取当前的线程对象"></a>获取当前的线程对象</h3><p>Thread类提供了一个静态方法currentThread()，该方法可以获取当前的线程对象，该方法出现在哪个线程中，获取的就是哪个线程对象。</p>
<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>Thread类中的静态方法sleep()可以使线程阻塞，Thread.sleep();这段代码出现在哪个线程里，该线程就陷入阻塞状态。</p>
<h4 id="关于sleep方法一道面试题"><a href="#关于sleep方法一道面试题" class="headerlink" title="关于sleep方法一道面试题"></a>关于sleep方法一道面试题</h4><p>看下面这段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread04 myThread04 = <span class="keyword">new</span> MyThread04();</span><br><span class="line">        myThread04.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            myThread04.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"main end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread04</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题是myThread04.sleep(1000 * 5);这段代码是否会使myThread04线程受阻。</p>
<p>答案是不会。</p>
<p>因为sleep方法是Thread类的静态方法，也就是说myThread04.sleep(1000 <em> 5);这段代码在执行时候实际上是Thread.sleep(1000 </em> 5);那么这段代码出现main方法中，也就是说会使main线程休眠5秒钟，跟MyThread04其实并没有关系。</p>
<h3 id="怎么唤醒一个正在睡眠的线程"><a href="#怎么唤醒一个正在睡眠的线程" class="headerlink" title="怎么唤醒一个正在睡眠的线程"></a>怎么唤醒一个正在睡眠的线程</h3><p>Thread类提供了一个interrupt方法，该方法是实例方法，可以终断正在睡眠的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread05 myThread05 = <span class="keyword">new</span> MyThread05();</span><br><span class="line">        myThread05.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        myThread05.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"main over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread05</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">365</span>);</span><br><span class="line">            System.out.println(<span class="string">"Sleep over"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会使MyThread05线程执行5秒后被终止。实现的原理是interrupt方法会使sleep方法出异常，这种使用异常终止的方式比较经典。</p>
<p><img src="/2022/02/25/%E4%B8%93%E9%A2%98-%E7%BA%BF%E7%A8%8B/image-20220208180003529.png" alt="image-20220208180003529"></p>
<h3 id="强行终止一个线程"><a href="#强行终止一个线程" class="headerlink" title="强行终止一个线程"></a>强行终止一个线程</h3><p>Thread类提供了一个stop方法，该方法是实例方法，可以强行终止一个线程。需要注意的是，这个方法已经过时，不推荐使用，因为强行终止一个程序可能会使数据丢失。</p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><h3 id="常见的线程调度模型"><a href="#常见的线程调度模型" class="headerlink" title="常见的线程调度模型"></a>常见的线程调度模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">抢占式调度模型：</span><br><span class="line">哪个线程的优先级比较高，抢到的CPU时间片的概率就高一些&#x2F;多一些。</span><br><span class="line">java采用的就是抢占式调度模型。</span><br><span class="line"></span><br><span class="line">均分式调度模型：</span><br><span class="line">平均分配CPU时间片。每个线程占有的CPU时间片时间长度一样。</span><br><span class="line">有一些编程语言，线程调度模型采用的是这种方式。</span><br></pre></td></tr></table></figure>
<h3 id="线程调度的几个方法"><a href="#线程调度的几个方法" class="headerlink" title="线程调度的几个方法"></a>线程调度的几个方法</h3><ul>
<li><p>实例方法：</p>
<pre><code>        void setPriority(int newPriority) 设置线程的优先级
        int getPriority() 获取线程优先级
        最低优先级1
        默认优先级是5
        最高优先级10
        优先级比较高的获取CPU时间片可能会多一些。（但也不完全是，大概率是多的。）
</code></pre></li>
<li><p>静态方法：</p>
<pre><code>        static void yield()  让位方法
        暂停当前正在执行的线程对象，并执行其他线程
        yield()方法不是阻塞方法。让当前线程让位，让给其它线程使用。
        yield()方法的执行会让当前线程从“运行状态”回到“就绪状态”。
        注意：在回到就绪之后，有可能还会再次抢到。        
</code></pre></li>
<li><p>实例方法：</p>
<pre><code>        void join() 合并线程
        t.join(); // 当前线程进入阻塞，t线程执行，直到t线程结束。当前线程才可以继续。
</code></pre><p>​           注意：合并线程并不是合并栈，而是两个线程之间存在等待关系（协调）。</p>
</li>
</ul>
<h2 id="线程安全（重点）"><a href="#线程安全（重点）" class="headerlink" title="线程安全（重点）"></a>线程安全（重点）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>开发中，我们的项目都是运行在服务器当中，而服务器已经将线程的定义，线程对象的创建，线程的启动等，都已经实现完了。这些代码我们都不需要编写。重要的是：你要知道，你编写的程序需要放到一个多线程的环境下运行，你更需要关注的是这些数据在多线程并发的环境下是否是安全的。</p>
<p>那么什么时候数据在多线程并发的环境下会存在线程安全问题？</p>
<p>三个条件：<br>    · 条件1：多线程并发。<br>    · 条件2：有共享数据。<br>    · 条件3：共享数据有修改的行为。</p>
<p>满足以上3个条件之后，就会存在线程安全问题。这个不安全体现在共享的数据不能实时同步到另一个线程中。（比如一个银行账户同时在ATM和柜台取款，最终只扣了一次款）。</p>
<p>解决线程安全问题，可以使用线程同步机制。所谓线程同步就是线程排队执行，也就是说线程不能并发了，这种解决方法就是牺牲程序的效率去保证安全。</p>
<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>synchronized用法1：线程同步代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(xx) &#123;code...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">()中写什么？</span><br><span class="line">    那要看你想让哪些线程同步。</span><br><span class="line">    假设t1、t2、t3、t4、t5，有5个线程，</span><br><span class="line">    你只希望t1 t2 t3排队，t4 t5不需要排队。怎么办？</span><br><span class="line">    你一定要在()中写一个t1 t2 t3共享的对象。而这个对象对于t4 t5来说不是共享的。</span><br></pre></td></tr></table></figure>
<p>原理：当一个线程的碰到同步代码块，它会去占有synchronized括号中的对象锁，在java语言中，任何一个对象都有一把锁，这个锁就是一个标记，当它占有后，有另一个线程也进入该代码块，当它碰到synchronized关键字，它也会去占有这把锁，但是当它发现这把锁已经被其他人占有了，它就会在代码块外面等待，直到这把锁被释放，它才会去占有这把锁，接着执行代码。这样就达到了排队的效果。</p>
<p>synchronized用法2：直接修饰在实例方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;code...&#125;</span><br></pre></td></tr></table></figure>
<p>这样写synchronized锁的就是this，同步整个方法体。所以这样写灵活性不高，效率很低，除非刚好符合这种情况，否则不推荐这样使用。</p>
<p>synchronized用法3：修饰在静态方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;code...&#125;</span><br></pre></td></tr></table></figure>
<p>表示找类锁。类锁永远只有1把。就算创建了100个对象，那类锁也只有一把。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁的规范定义：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。</p>
<p>一种情形，此时执行程序中两个或多个进程发生永久堵塞（等待），每个进程都在等待被其他进程占用并堵塞了的资源。例如，如果进程A锁住了记录1并等待记录2，而进程B锁住了记录2并等待记录1，这样两个进程就发生了死锁现象。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// t1和t2两个线程共享o1,o2</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> MyThread1(o1,o2);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> MyThread2(o1,o2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    Object o1;</span><br><span class="line">    Object o2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread1</span><span class="params">(Object o1,Object o2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.o1 = o1;</span><br><span class="line">        <span class="keyword">this</span>.o2 = o2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Object o1;</span><br><span class="line">    Object o2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread2</span><span class="params">(Object o1,Object o2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.o1 = o1;</span><br><span class="line">        <span class="keyword">this</span>.o2 = o2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于死锁的发生原因有很多种，上面只是其中的一种情形，也是比较典型的一种情况，还有其他很多复杂的情况，有兴趣的小伙伴可以自行找资料去了解。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>虽然使用线程同步机制可以解决线程安全问题，但是我们在解决的时候，不应该无脑的使用这种方式，因为这种方式执行效率很低，用户体验不好，系统的用户吞吐量降低，用户体验差。在不得已的情况下再选择线程同步机制。</p>
<p>再者，如果使用线程同步机制，需要注意点的是，要尽可能的减小效率的损失，也就说在同步代码块中的代码要尽可能的少。</p>
<p>那么除了线程同步机制，我们还可以采用以下的方法解决线程安全问题：</p>
<p>第一种方案：尽量使用局部变量代替“实例变量和静态变量”。</p>
<p>第二种方案：如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共享了。（一个线程对应1个对象，100个线程对应100个对象，对象不共享，就没有数据安全问题了。）</p>
<p>同时，使用线程同步机制，一定要避免死锁的问题，synchronized一定要尽可能的避免嵌套使用，一旦你的代码出现了死锁，那么离被开除也不远了。。</p>
<h2 id="延伸和拓展"><a href="#延伸和拓展" class="headerlink" title="延伸和拓展"></a>延伸和拓展</h2><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>java语言中线程分为两大类：<br>            一类是：用户线程<br>            一类是：守护线程（后台线程）<br>            其中具有代表性的就是：垃圾回收线程（守护线程）。</p>
<p>​    守护线程的特点：<br>​        一般守护线程是一个死循环，所有的用户线程只要结束，守护线程自动结束。</p>
<p>​    注意：主线程main方法是一个用户线程。</p>
<p>​    守护线程用在什么地方呢？<br>​        每天00:00的时候系统数据自动备份。这个需要使用到定时器，并且我们可以将定时器设置为守护线程。一直在那里看着，每到00:00的时候就备份一次。所有的用户线程如果结束了，守护线程自动退出，没有必要进行数据备份了。</p>
<p>代码实现非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread对象.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>定时器的作用：间隔特定的时间，执行特定的程序。</p>
<p>例如：</p>
<p>​        每周要进行银行账户的总账操作。<br>​        每天要进行数据的备份操作。</p>
<p>在实际的开发中，每隔多久执行一段特定的程序，这种需求是很常见的，<br>那么在java中其实可以采用多种方式实现：<br>            可以使用sleep方法，睡眠，设置睡眠时间，没到这个时间点醒来，执行<br>            任务。这种方式是最原始的定时器。（比较low）</p>
<p>​            在java的类库中已经写好了一个定时器：java.util.Timer，可以直接拿来用。<br>​            不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持<br>​            定时任务的。</p>
<p>​            在实际的开发中，目前使用较多的是Spring框架中提供的SpringTask框架，<br>​            这个框架只要进行简单的配置，就可以完成定时器的任务。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用定时器指定定时任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建定时器对象</span></span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="comment">//Timer timer = new Timer(true); //守护线程的方式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定定时任务</span></span><br><span class="line">        <span class="comment">//timer.schedule(定时任务, 第一次执行时间, 间隔多久执行一次);</span></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        Date firstTime = sdf.parse(<span class="string">"2020-03-14 09:34:30"</span>);</span><br><span class="line">        <span class="comment">//timer.schedule(new LogTimerTask() , firstTime, 1000 * 10);</span></span><br><span class="line">        <span class="comment">// 每年执行一次。</span></span><br><span class="line">        <span class="comment">//timer.schedule(new LogTimerTask() , firstTime, 1000 * 60 * 60 * 24 * 365);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类方式</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> TimerTask()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// code....</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; , firstTime, <span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个定时任务类</span></span><br><span class="line"><span class="comment">// 假设这是一个记录日志的定时任务</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 编写你需要执行的任务就行了。</span></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        String strTime = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(strTime + <span class="string">":成功完成了一次数据备份！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="wait和notify方法"><a href="#wait和notify方法" class="headerlink" title="wait和notify方法"></a>wait和notify方法</h3><p>第一：wait和notify方法不是线程对象的方法，是java中任何一个java对象都有的方法，因为这两个方式是Object类中自带的。<br>            wait方法和notify方法不是通过线程对象调用，<br>            不是这样的：t.wait()，也不是这样的：t.notify()..不对。</p>
<p>第二：wait()方法作用？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">o.wait();</span><br></pre></td></tr></table></figure>
<p>​        表示：<br>​            让正在o对象上活动的线程进入等待状态，无期限等待，直到被唤醒为止。<br>​            o.wait();方法的调用，会让“当前线程（正在o对象上活动的线程）”进入等待状态。</p>
<p>第三：notify()方法作用？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">o.notify();</span><br></pre></td></tr></table></figure>
<p>表示：唤醒正在o对象上等待的线程。<br>还有一个notifyAll()方法，这个方法是唤醒o对象上处于等待的所有线程。</p>
<h4 id="生产者和消费者模式"><a href="#生产者和消费者模式" class="headerlink" title="生产者和消费者模式"></a>生产者和消费者模式</h4><p>目的：为了达到生产和消费的均衡。生产到一定数量后就不生产了，必须要消费线程进行消费才能继续生产，同理，消费完了就必须让生产线程进行生产。这用wait和notify方法进行实现十分经典：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、使用wait方法和notify方法实现“生产者和消费者模式”</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、什么是“生产者和消费者模式”？</span></span><br><span class="line"><span class="comment">    生产线程负责生产，消费线程负责消费。</span></span><br><span class="line"><span class="comment">    生产线程和消费线程要达到均衡。</span></span><br><span class="line"><span class="comment">    这是一种特殊的业务需求，在这种特殊的情况下需要使用wait方法和notify方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、wait和notify方法不是线程对象的方法，是普通java对象都有的方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4、wait方法和notify方法建立在线程同步的基础之上。因为多线程要同时操作一个仓库。有线程安全问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5、wait方法作用：o.wait()让正在o对象上活动的线程t进入等待状态，并且释放掉t线程之前占有的o对象的锁。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6、notify方法作用：o.notify()让正在o对象上等待的线程唤醒，只是通知，不会释放o对象上之前占有的锁。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7、模拟这样一个需求：</span></span><br><span class="line"><span class="comment">    仓库我们采用List集合。</span></span><br><span class="line"><span class="comment">    List集合中假设只能存储1个元素。</span></span><br><span class="line"><span class="comment">    1个元素就表示仓库满了。</span></span><br><span class="line"><span class="comment">    如果List集合中元素个数是0，就表示仓库空了。</span></span><br><span class="line"><span class="comment">    保证List集合中永远都是最多存储1个元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    必须做到这种效果：生产1个消费1个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest16</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建1个仓库对象，共享的。</span></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">// 创建两个线程对象</span></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(list));</span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(list));</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">"生产者线程"</span>);</span><br><span class="line">        t2.setName(<span class="string">"消费者线程"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 仓库</span></span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一直生产（使用死循环来模拟一直生产）</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 给仓库对象list加锁。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                <span class="keyword">if</span>(list.size() &gt; <span class="number">0</span>)&#123; <span class="comment">// 大于0，说明仓库中已经有1个元素了。</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 当前线程进入等待状态，并且释放Producer之前占有的list集合的锁。</span></span><br><span class="line">                        list.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 程序能够执行到这里说明仓库是空的，可以生产</span></span><br><span class="line">                Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">                list.add(obj);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + obj);</span><br><span class="line">                <span class="comment">// 唤醒消费者进行消费</span></span><br><span class="line">                list.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 仓库</span></span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一直消费</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">                <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 仓库已经空了。</span></span><br><span class="line">                        <span class="comment">// 消费者线程等待，释放掉list集合的锁</span></span><br><span class="line">                        list.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 程序能够执行到此处说明仓库中有数据，进行消费。</span></span><br><span class="line">                Object obj = list.remove(<span class="number">0</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + obj);</span><br><span class="line">                <span class="comment">// 唤醒生产者生产。</span></span><br><span class="line">                list.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的一点是：wait和notify方法必须建立在synchronized线程同步的基础上。因为wait方法让会让该对象上活动的线程进入等待状态，并且释放掉之前占有的对象锁。如果没有占有，又何来释放，所以一定要配合synchronized来使用。</p>
<p>而notify方法只会通知唤醒，不会释放之前占有的对象锁。</p>
<p>———————————————————————————————————————————————————————————-到此为止线程专题全部结束了，感谢您的阅读!</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaSE/" rel="tag"># JavaSE</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3String%E7%B1%BB/" rel="prev" title="深入理解String类">
      <i class="fa fa-chevron-left"></i> 深入理解String类
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81NDMwNi8zMDc3Nw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程和线程的关系"><span class="nav-number">1.</span> <span class="nav-text">进程和线程的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程并发"><span class="nav-number">2.</span> <span class="nav-text">多线程并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现线程的三种方式"><span class="nav-number">3.</span> <span class="nav-text">实现线程的三种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一种方式"><span class="nav-number">3.1.</span> <span class="nav-text">第一种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二种方式"><span class="nav-number">3.2.</span> <span class="nav-text">第二种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以上两种方法有何区别"><span class="nav-number">3.3.</span> <span class="nav-text">以上两种方法有何区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三种方法"><span class="nav-number">3.4.</span> <span class="nav-text">第三种方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程是如何运行的"><span class="nav-number">4.</span> <span class="nav-text">线程是如何运行的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#run方法和start方法的区别"><span class="nav-number">4.1.</span> <span class="nav-text">run方法和start方法的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程并发并不是真正的并发"><span class="nav-number">4.2.</span> <span class="nav-text">多线程并发并不是真正的并发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的生命周期"><span class="nav-number">5.</span> <span class="nav-text">线程的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的几个常用方法"><span class="nav-number">6.</span> <span class="nav-text">线程的几个常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取当前的线程对象"><span class="nav-number">6.1.</span> <span class="nav-text">获取当前的线程对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep"><span class="nav-number">6.2.</span> <span class="nav-text">sleep</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#关于sleep方法一道面试题"><span class="nav-number">6.2.1.</span> <span class="nav-text">关于sleep方法一道面试题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#怎么唤醒一个正在睡眠的线程"><span class="nav-number">6.3.</span> <span class="nav-text">怎么唤醒一个正在睡眠的线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#强行终止一个线程"><span class="nav-number">6.4.</span> <span class="nav-text">强行终止一个线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程调度"><span class="nav-number">7.</span> <span class="nav-text">线程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的线程调度模型"><span class="nav-number">7.1.</span> <span class="nav-text">常见的线程调度模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程调度的几个方法"><span class="nav-number">7.2.</span> <span class="nav-text">线程调度的几个方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全（重点）"><span class="nav-number">8.</span> <span class="nav-text">线程安全（重点）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">8.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized关键字"><span class="nav-number">8.2.</span> <span class="nav-text">synchronized关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">8.3.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">8.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延伸和拓展"><span class="nav-number">9.</span> <span class="nav-text">延伸和拓展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#守护线程"><span class="nav-number">9.1.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定时器"><span class="nav-number">9.2.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait和notify方法"><span class="nav-number">9.3.</span> <span class="nav-text">wait和notify方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生产者和消费者模式"><span class="nav-number">9.3.1.</span> <span class="nav-text">生产者和消费者模式</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="BestSkyITWorld"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">BestSkyITWorld</p>
  <div class="site-description" itemprop="description">专于技术，不止于技术</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BestSkyITWorld</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">66k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:01</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
