<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>改变，就是好事</title>
    <url>/2020/07/11/%E6%94%B9%E5%8F%98%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%A5%BD%E4%BA%8B/</url>
    <content><![CDATA[<p>从小到大，我们听过也看过很多大道理，各种励志的鸡汤也看得不少，但是真正因此付出行动的少之又少，或者大多数时候，都是三分钟热度，还没坚持几天，便放弃了。到最后你会发现，道理你都懂，想的也很多，但做的却太少。</p>
<p><img src="/2020/07/11/%E6%94%B9%E5%8F%98%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%A5%BD%E4%BA%8B/image-20200712160418744.png" alt="image-20200712160418744"></p>
<a id="more"></a>

<h2 id="我们之所以这样，是因为缺少特殊的时期和境遇"><a href="#我们之所以这样，是因为缺少特殊的时期和境遇" class="headerlink" title="我们之所以这样，是因为缺少特殊的时期和境遇"></a>我们之所以这样，是因为缺少特殊的时期和境遇</h2><p>不要指望自己突然某天变得很自律，早睡早起锻炼身体，仅仅是因为看了一些狗血鸡汤，那显然不现实；你也不要指望自己突然某天变得热爱学习，每天看书刷题，仅仅是因为看了一些TED的演讲，把你说得热血沸腾。但这些你也不用责怪自己，因为如果你有这个觉悟，你早就已经改变了，你现在的一些习惯和行为，都是基于你过去这么多年累积下来的；当然如果你内心真的十分渴望改变，凭借你强大的意志力，是可以做到的，但大多数情况是，你的意志力十分薄弱。</p>
<p>再举个例子，人们总说要珍惜眼前的一切，但是如果你没有经历过家人朋友意外的离去，你又怎么会特别小心的珍惜跟他们在一起的时间。你没有注意到父母早已经有了皱纹和白发，身体已经一天不如一天，所以你还总是去跟他们吵架。</p>
<p>所以一个人成长和改变很多时候都不是主动，而是被动的。一个人如果从小到大家庭环境都很优越，那么他很可能就是从小玩大，他的观念一定不是好好学习，将来考上好的大学才好赚钱，因为他明白家里有的是钱，但是如果有一天，他家里破产，他的父母只能依靠他的时候，他就不得不去改掉原来的坏毛病，想尽办法去赚钱。一个整天胡吃海喝身材走样的胖子，当被自己喜欢的女生拒绝，但女生告诉他如果他减肥成功，就答应和他在一起，这男的一定会拼了老命去减肥。</p>
<p><label style="color:blue">然而这个过程，一定是痛苦的。</label></p>
<h3 id="《教父》—成长之路不易且痛苦"><a href="#《教父》—成长之路不易且痛苦" class="headerlink" title="《教父》—成长之路不易且痛苦"></a>《教父》—成长之路不易且痛苦</h3><p>我个人最喜欢的电影，好好地看几遍并且看懂，相信你一定会蜕变成另一个人。</p>
<p><img src="/2020/07/11/%E6%94%B9%E5%8F%98%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%A5%BD%E4%BA%8B/v2-efb974d107f19d702e10a4b3a6a79169_b.jpg" alt="v2-efb974d107f19d702e10a4b3a6a79169_b"></p>
<p>这部电影的主题是黑帮，老教父叫维托柯里昂，是个黑帮老大，他有三个儿子，一个大儿子桑尼，脾气暴躁，二儿子弗雷多，性格懦弱，最小的儿子迈克尔，上过大学，当过兵，不想插手父亲黑帮中的事，只想跟女朋友过安稳的生活。在第一部中，老教父中了枪，躺在医院昏迷不醒，医院中保护他的人被被收买的警察赶走，最后是三儿子站出来老教父才保住了命。最后大儿子因为冲动被人算计用枪活活扫死，二儿子懦弱没有担当，当老教父退下时，迈克尔不得不站出来，不然整个家族的人都有危险。他失去了原来渴望的平静生活，他不被妻子理解最后不得不分开，在电影中（小说好像不同），女儿最后也因为黑帮的纠纷被人杀害。</p>
<p>影片的结尾，迈克尔独自一人在西西里院子的椅子上死去。看完教父三部曲后，你能明白很多为人处世的道理，也能学会如何以一个男人的方式去正确的处理事情，它不仅仅是黑帮片，你能从中看到成长和孤独，看到痛苦和责任。迈克尔走上这条路，表面上被迫的，换个角度看，其实是主动的背负起了整个家族的责任。</p>
<p><img src="/2020/07/11/%E6%94%B9%E5%8F%98%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%A5%BD%E4%BA%8B/image-20200712151612512.png" alt="image-20200712151612512"></p>
<h2 id="生于忧患，死于安乐"><a href="#生于忧患，死于安乐" class="headerlink" title="生于忧患，死于安乐"></a>生于忧患，死于安乐</h2><p>我今天要说的重点，其实不是要强调成长是被迫的，相反，我觉得<label style="color:blue">与其被动的在痛苦中成长，不如主动的做出改变。</label></p>
<p>我不知道你们身边有没有这样的人，家庭条件也一般，但整天无所事事，不是玩游戏就是睡觉，一点上进心没有，没有危机感也没有紧迫感，反正过一天算一天，这个世界上所有的事情好像都跟他无关。</p>
<h3 id="这个时代的年轻人，本该尝过生活的苦，但他们的父母，替他们扛下了所有"><a href="#这个时代的年轻人，本该尝过生活的苦，但他们的父母，替他们扛下了所有" class="headerlink" title="这个时代的年轻人，本该尝过生活的苦，但他们的父母，替他们扛下了所有"></a>这个时代的年轻人，本该尝过生活的苦，但他们的父母，替他们扛下了所有</h3><p>有多少无忧无虑年轻人的生活，是父母的汗水和鲜血换来的。当你还在嫌弃菜不好吃的时候，有想过父母吃着隔夜的饭菜吗；当你身穿名牌跟别人攀比的时候，有想过父母那多少年没有换过的鞋子吗。</p>
<p>之前看到过这么一句话：如果你的父母每天还很辛苦，那么我们长大的意义又是什么？</p>
<p>小的时候渴望长大，憧憬当大人的自由，现在长大了，能抽烟喝酒，能去网吧开黑，但这真的是长大的意义吗？长大是主动的背负起责任，是让那些在你小的时候，保护你的人，现在被你保护。</p>
<h3 id="你要被需要"><a href="#你要被需要" class="headerlink" title="你要被需要"></a>你要被需要</h3><p>不要总是当那个需要别人的人。</p>
<p>有的时候我会想，当自己的家人亲戚朋友遇到困难的时候，如果自己能够站出来那该多好，当自己有能力了，能被人坚定的相信和需要了，那是件多么幸福的事情。想一想未来自己的父母都已老去，当他们需要你的时候，你能不能成为他们坚强的依靠。</p>
<p><label style="color:blue">所以主动去改变自己吧，把责任和被人需要的感觉当成自己前行的动力。</label></p>
<h2 id="活在未来，而不是活在当下"><a href="#活在未来，而不是活在当下" class="headerlink" title="活在未来，而不是活在当下"></a>活在未来，而不是活在当下</h2><p>你要相信，优秀的人一定是活在未来，而不是活下当下，及时行乐。活在未来是一种思维，这样的人是有远见的人，他们不会痴迷于现状的美好，而是敢于去预测未来的不确定，为此做好准备。</p>
<p>或许很多人现在过着小康生活，日子安稳幸福，但你要明白，<label style="color:blue">所有的事情不会像你想的那样一成不变</label>，人活着一定要有一点危机感，这样才能进步。</p>
<p>当生活突如其来的给你来一场灾难，如果你没做好准备，那么你会被伤得体无完肤。也许这时你会说，这不是你所说的被迫成长吗？</p>
<p>没错，每个人都会经历这样的成长，但我说过，这个过程是十分痛苦的，你本可以减轻伤害，甚至避免，只要你之前主动做出过改变。</p>
<p>这就是主动去改变、活在未来的重要性，你只有越优秀，你的铠甲才会越厚，而不是受到伤害后，才意识到自己薄弱的身躯。</p>
<p>你可能会说，到头来，你这他妈还不是一篇狗血鸡汤吗？你可以这么认为，但我没说过这个世界很美好，也没说过成长很幸福，我告诉你的是，成长必定是痛苦的，你可能会疼死，但你可以打预防针或者吃止痛药。</p>
<p>这不是鸡汤，这是哲学和智慧。</p>
<p>我特别喜欢英雄联盟，其中一些人物有许多富含哲理的话：改变，就是好事。—卡兹克</p>
<p><img src="/2020/07/11/%E6%94%B9%E5%8F%98%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%A5%BD%E4%BA%8B/image-20200712155832581.png" alt="image-20200712155832581"></p>
<p>——————持续更新中</p>
]]></content>
      <categories>
        <category>人生啊</category>
      </categories>
      <tags>
        <tag>人生啊</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊Java这条路该怎么走</title>
    <url>/2020/07/09/%E8%81%8A%E4%B8%80%E8%81%8AJava%E8%BF%99%E6%9D%A1%E8%B7%AF%E8%AF%A5%E6%80%8E%E4%B9%88%E8%B5%B0/</url>
    <content><![CDATA[<p>网上有很多关于Java学习路线的帖子，有些列了很长的思维导图，看着很费劲也看不明白，还有一些讲得太深，对于初学者来说不太友好。今天我从零开始给大家讲讲从起步到工作需要哪些技术，这些技术大概是做什么的。文章有点长，如果耐心看完，相信对你今后的学习规划和进度会有很大的帮助。</p>
<p><img src="/2020/07/09/%E8%81%8A%E4%B8%80%E8%81%8AJava%E8%BF%99%E6%9D%A1%E8%B7%AF%E8%AF%A5%E6%80%8E%E4%B9%88%E8%B5%B0/image-20200709143657327.png" alt="image-20200709143657327"></p>
<a id="more"></a>

<h2 id="Java开发到底是做什么"><a href="#Java开发到底是做什么" class="headerlink" title="Java开发到底是做什么"></a>Java开发到底是做什么</h2><p>就目前来讲，基于Java开发一共有两条路可走，第一条路就是安卓开发，有人说现在安卓就业不太友好，因为现在App太多，好像谁都能做一样，所以竞争很激烈，一个产品想要面向市场做的很好，难度非常大，另一种说法就是对立了，因为现在智能手机的普及，人们对于App的需求也变高了，所以这算是优势。</p>
<p>但Java最主要的开发方向，就是基于Web开发，也就是我们所说的网页后台开发。Java在这个行业有着天然的优势，高并发性能好，开源项目生态好，所有的大型网站，像淘宝、京东这些大型电商网站，不可能用其他语言作为后台语言，虽然Python、PHP也能做，但是网站一旦做大了，它们根本没法稳定的运行。淘宝最开始是用的PHP，但是随着用的人越来越多，最后他们把整个项目换成了Java。</p>
<p>顺带提一下桌面应用开发，想要做这个行业的小伙伴我可以直接劝退了，因为Java不适合做桌面应用程序的开发，虽然Java可以用awt、swing设计图形界面，但是性能太低而且可以移植性也差，基本已经凉凉了。所以想要做游戏或者其他的桌面程序的小伙伴们可以去学C#，也是非常香的。</p>
<p>下面简单的用导图列出了整个学习的路线，具体的内容将在文章中详细介绍。</p>
<p><img src="/2020/07/09/%E8%81%8A%E4%B8%80%E8%81%8AJava%E8%BF%99%E6%9D%A1%E8%B7%AF%E8%AF%A5%E6%80%8E%E4%B9%88%E8%B5%B0/image-20200709205248022.png" alt="image-20200709205248022"></p>
<h2 id="阶段一：JavaSE"><a href="#阶段一：JavaSE" class="headerlink" title="阶段一：JavaSE"></a>阶段一：JavaSE</h2><p>JavaSE就是Java Standard Edition，Java标准版本，这个阶段我们学的就是Java的语法还有Java的特性，很多人对于学Java有误解，认为学Java就是学的JavaSE，这是很天真的想法，这个阶段的学习专业点的术语叫做MAS（Minimum action step）最小行动步骤，什么意思呢？就是如果你只学了JavaSE，那么你什么都干不了，如果你不学，那么后面的技术你同样也学不了。所以这个阶段的学习十分重要，就是打地基，你学的越扎实，后面越轻松。</p>
<p>还有一点要提的是：我建议在开始学Java之前，最好学一下C语言。Java其实跟C语言非常像，因为Java就是用C和C++写的，但是摈弃了C和C++中一些不安全的操作和进行了优化改进，学完C语言后能和Java进行无缝对接，而且很多知识点在C语言出现过的，可以一带而过，so easy too happy。这里我推荐郝斌老师的C语言教程，我对郝斌老师的感情可以说是非常深了，因为最开始入这个门就是看他的视频，讲得通俗易懂而且还很幽默，完全不会因为代码的枯燥而无聊，反正无脑吹就对了。他有C和Java的教学视频，当然还有数据结构和Sql Server的视频，我当初看完C立马接着看他的Java视频了，连接非常顺畅。但是这里我还是推荐看其他新一点的视频，因为郝斌老师的视频是09年录的，稍稍有点老了，推荐动力节点的Java教程，比较新而且非常非常非常全，老师也是非常不错。（这些视频b站上都能直接搜到，完全免费还带资料。下面所有的技术你都能在b站上找到很好教程，外面几万块的课全部免费，我的大学基本就是在b站读的….）</p>
<h2 id="阶段二：MySql和JDBC"><a href="#阶段二：MySql和JDBC" class="headerlink" title="阶段二：MySql和JDBC"></a>阶段二：MySql和JDBC</h2><h3 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h3><p>Mysql就是数据库的一种，这个阶段的学习也是非常非常重要，是难点也是重点。现在的软件开发行业，不管你学的什么语言，你不学数据库，你根本做不了开发，为什么这么说，因为只要你是做程序开发的，必定离不开对数据的操作，比方说，你进入一个网站或者一个app，你肯定要注册登录吧，那么你的账号密码就要存储吧，不然你下次怎么登陆呢？那么怎么存呢？存在程序里吗？第一你存不了这么多数据，你的ROM就这么点大还这么贵，就算你能存吧，你这程序一停止，或者你电脑一关机，你的数据就没了。你用Excel存吗？一个平台的人数这么多，就算你能存吧，你打开这个文件不知道要多久，况且这么多数据查找非常慢，所以你就需要数据库，它其实就是一个类似于Excel的东西，只不过存储性能极高，能存储千万级数据，查找数据极快，现阶段的学习主要学的是对数据的增删改查，包括你以后在公司里做的，八九也就是增删改查，重点也就是查。但你要进阶的往下学，底层的东西和高级部分就有点难了，推荐在学完整个基础后，回过头来好好学学原理。</p>
<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>JDBC（Java Database Connectivity），Java数据库连接，简单来讲就是如何用Java去操作数据库，这算是一个小小的技术，学起来非常快，但很实用，它将会伴随你整个开发生涯。</p>
<h2 id="阶段三：网页前端技术"><a href="#阶段三：网页前端技术" class="headerlink" title="阶段三：网页前端技术"></a>阶段三：网页前端技术</h2><h3 id="什么是前端和后端？"><a href="#什么是前端和后端？" class="headerlink" title="什么是前端和后端？"></a>什么是前端和后端？</h3><p>相信很多小伙伴都有听说过前端和后端，但不是很了解，这里我给大家简单的说下什么是前端什么是后端。</p>
<p>前端技术就是你所能看到的东西，例如一个网页有背景，有列表分类，有搜索框，这些东西就是前端要写的东西，而后端就是你点击搜索后，会呈现你想要搜索的内容，它后台是怎么查找的你看不到，你在页面上只能看到结果，我们做Java开发，主要就是对于后台功能的实现。</p>
<h4 id="为啥要学前端？"><a href="#为啥要学前端？" class="headerlink" title="为啥要学前端？"></a>为啥要学前端？</h4><p>那么问题来了，我们学后端的人，为啥要学前端呢？刚开始也我很苦恼，心想，这种东西难道公司里没有什么学设计的小姐姐去搞吗？我凭什么要把页面做的这么好看，我只要把功能写出来就行了啊。但事实是，你一开始去的公司，很可能是小公司，公司为了节省成本和人力，你基本上要把前后端的活全包了，这样公司能少发一个人的工资。当然你进了大厂，那么基本上公司里的项目都是前后端分离的，你不用关心前端的代码，你只要写好你的功能就行了。所以保险起见，我建议小伙伴们还是要好好学前端，我看了很多公司的招聘，他们都是要求会前端的，他们的要求里写的很明白，会前端框架的优先考虑，所以这绝对是加分项了（我现在就很后悔我前端没好好学）。当然学习前端也不仅仅是这个原因，因为我们在写后台的时候，总会去前端去取数据，那么如果你前端一窍不通，你压根就没法操作，你不知道这个数据是怎么传过来的，也不知道怎么把数据回传给前端页面，所以前端可以不学精，但一定要学，或多或少会一点即可。</p>
<h3 id="前端的三门主要技术"><a href="#前端的三门主要技术" class="headerlink" title="前端的三门主要技术"></a>前端的三门主要技术</h3><h4 id="HTML-amp-CSS-amp-JavaScript"><a href="#HTML-amp-CSS-amp-JavaScript" class="headerlink" title="HTML&amp;CSS&amp;JavaScript"></a>HTML&amp;CSS&amp;JavaScript</h4><p>简单的介绍一下这三门技术：HTML就是网页的骨架，就好比建房子时，整个的框架，CSS就是如何把网页装饰的很漂亮，好比房子的装修，而JavaScript就是让这个网页”动”起来，好比你房子的各种智能家居，你不用手动拉窗帘，你可以用手机去控制窗帘的开关。</p>
<p>另外，这三门技术都是脚本语言，就是不用编译就能运行，只要你有浏览器就行，你代码语法错误它也照常能运行，属于弱类型的语言。还有一点就是JavaScript，很多人有误解，认为它跟Java有什么关系，实际上压根就没关系，如果非要说有关系，那么就是它的语法跟Java很像而已（它原来不叫JavaScript，后来改成这个就是为了蹭Java的热度）。</p>
<h5 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h5><p>Jquery就是一个JavaScript的类库，能更方便的使用一些函数，它对JavaScript进行了简单的封装，能很方便对各种元素进行操作。</p>
<h2 id="阶段四：JavaWeb"><a href="#阶段四：JavaWeb" class="headerlink" title="阶段四：JavaWeb"></a>阶段四：JavaWeb</h2><p>学到这里，那么恭喜你，你已经可以完成一个网站的一些基本功能了，在2000年左右的时候已经能找到一份不错的工作了。但是技术升级得非常快，如今停留在这个阶段，工作是远远不够的。</p>
<p>这个阶段的学习，就是学习如何将前后端交互，完成一个功能。这里综合了你前面所有学习到技术，你将会用到数据库去验证账号密码是否正确，你将会从数据库取到数据传递给前端页面显示，你也能够完成一个账号密码真正意义上的修改（从网页修改数据库中的数据）。所以你不难发现，你这些功能永远都在跟数据库打交道，这也是我在前面讲的，为什么数据库这么重要的原因。</p>
<p>除此之外，你还能学习很多新的小技术，例如没有登录之前，无法进入指定的页面（Filter过滤器，Session会话），记住账号密码（Cookie），还有文件上传和邮件发送等功能。</p>
<p>但是这个阶段的学习你一定是痛苦的（至少我是很痛苦的），第一：代码量非常多。第二：有很多莫名其妙的bug（各种疑难杂症，非常搞心态）。</p>
<h2 id="阶段五：SSM框架"><a href="#阶段五：SSM框架" class="headerlink" title="阶段五：SSM框架"></a>阶段五：SSM框架</h2><p>上一阶段的学习中，你会发现代码非常繁琐，而且有大量的重复代码，另外数据库的查询语句写起来也是十分麻烦。这个阶段的学习你将会翻开崭新的一页：Spring框架（顾名思义，你的春天来临了）。框架就是在原来JavaWeb的基础上，对一些代码进行封装，你原来要写十几行的代码，现在一行就搞定了。那么你可能会疑惑，我直接学SSM不行吗，答案是：可以。我们之所以要学JavaWeb是因为它是底层基础的东西，你只有知道JavaWeb有多麻烦，才知道SSM存在的意义。</p>
<p>SSM是三个框架的首字母缩写，对应的是Spring，SpringMVC，Mybatis，每一个框架都对原来JavaWeb阶段的MVC三层架构进行了更简便的操作，SpringMVC对应视图层（控制请求，传递数据），Spring对应业务层（处理业务），Mybatis对应持久层（操作数据库）。这里听不懂也没有关系，当你学到这里的时候，自然会明白。</p>
<p>学完SSM后一基本上可以在公司干点活儿啦，因为现在很多公司的项目都在用SSM，但如果想要进更好的公司，你还要继续学习。</p>
<h2 id="阶段六：SpringBoot-VUE"><a href="#阶段六：SpringBoot-VUE" class="headerlink" title="阶段六：SpringBoot+VUE"></a>阶段六：SpringBoot+VUE</h2><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>当偷懒的程序员们对代码封装开发了SSM框架后，发现还不够偷懒，因为配置文件是在是太多了，所以又开始研发新的框架（人类的懒惰是会让技术进步的），于是新的框架又产生了：SpringBoot。简单来讲，SpringBoot就是在原先SSM框架上又进行了一次封装，省去了很多配置文件。</p>
<h3 id="Duubo-Zookeeper"><a href="#Duubo-Zookeeper" class="headerlink" title="Duubo+Zookeeper"></a>Duubo+Zookeeper</h3><p>在SpringBoot的学习中你将会学到这两项技术，它们是基于分布式系统提出的方案，也叫微服务。</p>
<h3 id="VUE（真正实现了前后端分离）"><a href="#VUE（真正实现了前后端分离）" class="headerlink" title="VUE（真正实现了前后端分离）"></a>VUE（真正实现了前后端分离）</h3><p>这里又出现了前端的东西，VUE是一个前端的框架，在如今的前后端分离时代，前端只管写前端页面，后端只用提供接口就行，现在很多公司都要求后端开发会VUE（真是太难了）。</p>
<p>当你完成这一阶段的学习，你已经能去一些中型的公司啦，稍微找一家好点公司，月薪7k+应该问题不大。这时候你也成为了一个合格码农，但是码农其实是很低级的，对于聪明的你，应该有更高的追求。</p>
<h2 id="阶段七：微服务"><a href="#阶段七：微服务" class="headerlink" title="阶段七：微服务"></a>阶段七：微服务</h2><h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><p>SpringCloud算是这几年的Web开发的潮流和趋势，它是基于分布式系统提出的一套完善的方案。你可以理解成有很多个SpringBoot的项目结合在一起，然后SpringCloud就是用来统一维护和管理这些项目(模块化)。大型公司都在用，但是小公司因为业务小的可怜，所以基本上也用不到，但这个技术一定是未来的趋势。学就完事了。</p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>Git入门非常快，几个小时就搞定了，它主要是用来管理项目和团队开发的，这个在工作之前最好学一下。</p>
<h2 id="阶段八：扩展和完善"><a href="#阶段八：扩展和完善" class="headerlink" title="阶段八：扩展和完善"></a>阶段八：扩展和完善</h2><p>当你完成上面七个阶段的学习，你可能会觉得你已经无敌了，你可能长叹一口气，心想，终于结束了，我当初也是这么想的，但后来才发现，原来所谓的结束，其实是另一轮更高难度关卡的开始······</p>
<h3 id="等待你的，是更多你不知道的东西"><a href="#等待你的，是更多你不知道的东西" class="headerlink" title="等待你的，是更多你不知道的东西"></a>等待你的，是更多你不知道的东西</h3><p>1、Linux（你的项目会放在上面运行）</p>
<p>2、JVM（大厂面试高频）</p>
<p>3、Redis（nosql数据库）</p>
<p>4、RocketMQ\RabbitMQ（消息队列）</p>
<p>5、Docker（集装箱）</p>
<p>6、Mycat（数据库中间件）</p>
<p>7、设计模式（很重要）</p>
<p>等等····</p>
<p>想要成为真正的程序员，你一定要会的两个东西：数据结构+算法，大厂非常喜欢算法好的童鞋。除此之外，你还要回过头来探究各种源码，JDK源码、Spring源码，SpringBoot源码，数据库底层原理，等等等等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先感谢你能耐心的看到这里。</p>
<p>必须得承认的是，这条路确实不好走，但是别人也不好走，80%的人在中间的时候就放弃了，最后剩下的人寥寥无几。有些人在JavaSE的时候就已经放弃了，因为发现自己压根不适合敲代码；有些人在学前端的时候发现前端更有意思可能转前端了；有些人在JavaWeb时候因为太难bug太多也放弃了，能坚持到最后的人又有多少呢，所以不要恐惧，如果你真的想做这一行，趁年轻试一试，万一成功了呢。另外，如果你跟我一样，对代码是感兴趣的，一定要保持这颗初心，不要气馁和烦躁，当觉得自己快坚持不下去的时候，回过头来想想以前的初衷，调整状态，继续前进。</p>
<p>祝各位早日年入百万。</p>
<p>——————持续更新中                                                                                                                    </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>学习路线</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>公告</title>
    <url>/2021/01/17/%E5%85%AC%E5%91%8A/</url>
    <content><![CDATA[<p>技术文章先暂时断更，因为在忙专升本的事情，今年4月份考试完之后会正常更新。到时候会先把23种设计模式更完，然后再更框架的东西，正好这么长时间没碰，自己也能复习一下，内容大概就是SSM和Spring的使用、项目的搭建再到源码的分析。如果时间允许再更一些MySql的东西。不管有没有人看，我会尽量坚持下去。</p>
<p><img src="/2021/01/17/%E5%85%AC%E5%91%8A/image-20210117151457493.png" alt="image-20210117151457493"></p>
]]></content>
  </entry>
  <entry>
    <title>设计模式-工厂模式</title>
    <url>/2020/07/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="工厂模式简介"><a href="#工厂模式简介" class="headerlink" title="工厂模式简介"></a>工厂模式简介</h2><p>定义：工厂顾名思义就是创建产品，所谓产品在Java中指的就是具体的对象，工厂模式就是将对象的实例化在工厂中完成。工厂模式属于创建型模式的一种，根据不同的使用场景，工厂模式又可以细分为：1、简单工厂模式  2、工厂方法模式  3、抽象工厂模式</p>
<p><img src="/2020/07/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20200718195250287.png" alt="image-20200718195250287"></p>
<a id="more"></a>

<p>设计目的：为了解耦，把对象的创建和使用过程分开，便于扩展和维护。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>我们来看一个需求：假设有一个接口为食品接口，在其实现类中有具体的产品，这些产品都要实现接口中的eat()方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hamburger</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chips</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃薯条"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line"><span class="comment">/*这条线代表时空线，在这条线之上为源码的设计者，而下面的代码为客户端的使用者，</span></span><br><span class="line"><span class="comment">  也就是说客户端的使用者是有可能拿不到上面的源码。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Food food = <span class="keyword">new</span> Hamburger();</span><br><span class="line">        food.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题分析：假如源码的设计者升级了原来的代码，例如将上面的Hamburger升级成了BigHamburger，那么客户端原来类名也要更换为BigHamburger，显然这样代码的耦合度太高，服务器端代码的修改直接影响客户端的代码，不符合面向接口的编程思想。</p>
<h2 id="简单工厂设计模式"><a href="#简单工厂设计模式" class="headerlink" title="简单工厂设计模式"></a>简单工厂设计模式</h2><p>针对上个问题，将原来的代码进行改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hamburger</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chips</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃薯条"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增工厂类，获取食品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title">getFood</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Food food = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                food = <span class="keyword">new</span> Hamburger();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                food = <span class="keyword">new</span> Chips();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line"><span class="comment">/*这条线代表时空线，在这条线之上为源码的设计者，而下面的代码为客户端的使用者，</span></span><br><span class="line"><span class="comment">  也就是说客户端的使用者是有可能拿不到上面的源码。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Food food = FoodFactory.getFood(<span class="number">1</span>);</span><br><span class="line">        food.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单工厂模式分析"><a href="#简单工厂模式分析" class="headerlink" title="简单工厂模式分析"></a>简单工厂模式分析</h3><p>我们设计了一个食品工厂类(FoodFactory)，这个类负责生产食品，这样设计的好处在于，当我们再次把Hamburger升级成BigHamburger时，只需要在工厂类中把switch分支中的类名也进行修改，这样不管我们的产品怎么变，对于客户端来说只需要知道getFood方法中参数对应的食品即可拿到对应食品。</p>
<div class="note success">
            <p>优点：把具体产品的类名，从客户端解耦出来，这符合了面向接口的编程思想。</p>
          </div>

<div class="note danger">
            <p>缺点：1、当产品有很多时，会产生很多case分支，假设有1000种食品，就要有1000case，代码过于臃肿。</p><p>​            2、最终要的是，如果客户端要扩展产品，那么就要在源码中增加代码，第一，这违反了设计模式的<label style="color:red">开闭原则</label>，第二这样是不现实的，你穿越了时空线！！在设计模式中，我们针对的是在手头没有源码的情况下进行编程的，再者，就算你有源码，你也不能修改，试问你能直接修改JDK的源码吗？</p>
          </div>

<div class="note info">
            <p>总结：简单工厂模式适用于<label style="color:#00CCFF">没有扩展需求</label>(增加类)但有<label style="color:#00CCFF">升级需求</label>(修改原有类)的业务中。</p>
          </div>

<h2 id="工厂方法设计模式"><a href="#工厂方法设计模式" class="headerlink" title="工厂方法设计模式"></a>工厂方法设计模式</h2><p>针对上述代码在客户端扩展的问题，引入工厂方法设计模式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hamburger</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chips</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃薯条"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增食品工厂接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Food <span class="title">getFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HamburgerFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hamburger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChipsFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Chips();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================</span></span><br><span class="line"><span class="comment">/*这条线代表时空线，在这条线之上为源码的设计者，而下面的代码为客户端的使用者，</span></span><br><span class="line"><span class="comment">  也就是说客户端的使用者是有可能拿不到上面的源码。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新增牛排类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Steak</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃牛排"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SteakFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Steak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SteakFactory steakFactory = <span class="keyword">new</span> SteakFactory();</span><br><span class="line">        Food food = steakFactory.getFood();</span><br><span class="line">        food.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂方法设计模式分析"><a href="#工厂方法设计模式分析" class="headerlink" title="工厂方法设计模式分析"></a>工厂方法设计模式分析</h3><p>我们将原来的FoodFactory设计成一个接口，再增加一个具体的食品工厂类去实现FoodFactory去生产食品。这样我们在客户端增加一个产品时，只需要增加一个产品类，再增加一个产品工厂去实现FoodFactory，就能使用了！</p>
<div class="note success">
            <p>优点：当客户端增加一个产品时，只需要增加一个工厂即可，不需要修改源代码。</p>
          </div>

<div class="note warning">
            <p>不足：假设现在又想要扩展一个产品等级(饮料类)，这个类不同于Food，那么我们又要增加一个工厂接口：DrinkFactory，如果有很多这样的需求，例如甜品、小吃，那么工厂的类就会很多很多，这样就不利于代码维护了。</p>
          </div>

<div class="note info">
            <p>总结：工厂方法设计模式适用于<label style="color:#00CCFF">同一个产品等级</label>，或者较少的产品等级的业务。</p>
          </div>

<h2 id="抽象工厂设计模式"><a href="#抽象工厂设计模式" class="headerlink" title="抽象工厂设计模式"></a>抽象工厂设计模式</h2><p>针对工厂方法产品等级扩展的需求，我们发现原来的FoodFactory还不够抽象，这个工厂只生产食品，如果需要生产饮料，那么又要定义一个饮料工厂，如果我们对FoodFactory再进行一层的抽象，直接变为一个可以生产任何种类食品的工厂，那么问题就解决了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一个饮料类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hamburger</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chips</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃薯条"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cola</span> <span class="keyword">implements</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"喝可乐"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将原来的FoodFactory抽象为Factory</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Food <span class="title">getFood</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Drink <span class="title">getDrink</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一个KFC工厂，同时生产饮料和食物</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hamburger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drink <span class="title">getDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cola();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> KFCFactory();</span><br><span class="line">        factory.getDrink();</span><br><span class="line">        factory.getFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象工厂设计模式分析"><a href="#抽象工厂设计模式分析" class="headerlink" title="抽象工厂设计模式分析"></a>抽象工厂设计模式分析</h3><p>抽象工厂模式的要点在于：它是对工厂的进一步抽象，用来生产<label style="color:#00CCFF">不同品种的产品</label>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h3><p>在JDK的中的java.util.Calendar类中的createCalendar就使用了简单工厂模式，部分源码如下：</p>
<p><img src="/2020/07/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20200718193840895.png" alt="image-20200718193840895"></p>
<h3 id="设计核心思想"><a href="#设计核心思想" class="headerlink" title="设计核心思想"></a>设计核心思想</h3><p>将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。  </p>
<h3 id="三种工厂模式使用场景"><a href="#三种工厂模式使用场景" class="headerlink" title="三种工厂模式使用场景"></a>三种工厂模式使用场景</h3><p>其实以上的三种工厂设计模式并没有谁更优秀这种说法，每一种设计模式对应的都是不同场景需求下所设计的，只有谁更合适，没有谁更优秀，没有哪一种设计模式是完美的。</p>
<p>那么这三种工厂模式具体在什么需求下使用呢？其实这个问题在上面都有总结了，为了加深大家的理解，我们需要了解产品等级和产品簇这两个概念：</p>
<p><img src="/2020/07/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20200718191553165.png" alt="image-20200718191553165"></p>
<div class="note primary">
            <p>当产品等级只有一个，并且该产品不会再扩展其他品牌，只会对原有的产品进行升级时，使用<label style="color:#00CCFF">简单工厂模式。</label></p><p>例如：只有腾讯、华为、美的、海尔、格力的电冰箱，<label style="color:#00CCFF">不会再增加其他品牌的冰箱</label>，并且只会对这些品牌的冰箱进行升级。</p>
          </div>

<div class="note primary">
            <p>当产品等级只有一个，不存在产品簇时，相同产品等级下还会再<label style="color:#00CCFF">扩展其他品牌</label>，使用<label style="color:#00CCFF">工厂方法模式。</label></p><p>例如：只有腾讯、华为、美的、海尔、格力的电冰箱，这时还需要<label style="color:#00CCFF">增加一个小米的电冰箱</label>，就可以使用工厂方法模式。</p>
          </div>

<div class="note primary">
            <p>当产品等级有多个，<label style="color:#00CCFF">产品簇较大</label>，需要增加产品等级时，使用<label style="color:#00CCFF">抽象工厂模式。</label></p><p>例如：各个品牌都有洗衣机、电冰箱、电视机、微波炉、笔记本，这时需要在每个品牌下新增一个电饭煲<label style="color:#00CCFF">(增加一个产品等级)</label>，就可以使用抽象工厂模式。</p>
          </div>

<p>到此为止，工厂设计模式就结束了，感谢您的阅读。</p>
<p><img src="/2020/07/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20200718195319047.png" alt="image-20200718195319047"></p>
<p>——————设计模式持续更新中。</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>工厂模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例模式</title>
    <url>/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="单例设计模式简介"><a href="#单例设计模式简介" class="headerlink" title="单例设计模式简介"></a>单例设计模式简介</h2><p>我们都知道在Java中可以new出一个或者多个对象实例，而所谓的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<label style="color:#00CCFF">只能存在一个对象实例</label>，并且该类只提供一个获得其对象实例的<label style="color:#00CCFF">静态方法</label>  。</p>
<p><img src="/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200713193236863.png" alt="image-20200713193236863"></p>
<a id="more"></a>

<h3 id="单例模式使用场景"><a href="#单例模式使用场景" class="headerlink" title="单例模式使用场景"></a>单例模式使用场景</h3><p>1、需要频繁的创建和销毁的对象</p>
<p>2、创建对象时耗费资源或时间过多（即重量级对象）</p>
<p>3、经常要用到的对象： 工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等)  </p>
<h3 id="介绍小结"><a href="#介绍小结" class="headerlink" title="介绍小结"></a>介绍小结</h3><p>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能 ；当想实例化一个单例类的时候，必须要使用相应的获取对象的方法，而不是使用new 。 </p>
<h2 id="单例模式的代码实现方式"><a href="#单例模式的代码实现方式" class="headerlink" title="单例模式的代码实现方式"></a>单例模式的代码实现方式</h2><p>单例模式一共有八种实现方式：</p>
<p><label style="color:red">1)饿汉式(静态常量) </label></p>
<p><label style="color:red">2)饿汉式（静态代码块）  </label></p>
<p>3)懒汉式(线程不安全) </p>
<p>4)懒汉式(线程安全，同步方法) </p>
<p>5)懒汉式(同步代码块)  </p>
<p><label style="color:red">6)双重检查  </label></p>
<p><label style="color:red">7)静态内部类  </label></p>
<p><label style="color:red">8)枚举  </label></p>
<p>tip:标红的是推荐使用，黑色表示能实现但是不推荐使用</p>
<h3 id="1-饿汉式-静态常量"><a href="#1-饿汉式-静态常量" class="headerlink" title="(1)饿汉式(静态常量)"></a>(1)饿汉式(静态常量)</h3><p>基本步骤：构造器私有化（防止new）==&gt;在类的内部创建对象==&gt;对外提供一个获得对象实例的方法（getInstance）</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">		System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对外提供方法获得对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点分析：</p>
<p>优点：写法简单，在类加载的时候完成初始化，避免了线程同步的问题。</p>
<p>缺点：因为是在类加载的时候完成初始化，没有达到<label style="color:red">懒加载的效果</label>，如果从始至终都没有使用这个实例，会造成内存的浪费。</p>
<p>总结：  这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用  getInstance方法，但是导致类装载的原因有很多种，例如类的其他方法被调用等，因此不能确定有其他的方式（其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading（懒加载）的效果  。</p>
<h3 id="2-饿汉式-静态代码块"><a href="#2-饿汉式-静态代码块" class="headerlink" title="(2)饿汉式(静态代码块)"></a>(2)饿汉式(静态代码块)</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</p>
<p><label style="color:red"> 结论：这种单例模式可用，但是可能造成内存浪费。</label></p>
<h3 id="3-懒汉式-线程不安全"><a href="#3-懒汉式-线程不安全" class="headerlink" title="(3)懒汉式(线程不安全)"></a>(3)懒汉式(线程不安全)</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建instance  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点分析：</p>
<p>优点：只有在用到的时候才去创建实例，起到了懒加载的效果。</p>
<p>缺点：<label style="color:red">线程不安全。</label>  在多线程下，如果一个线程进入了 if (singleton  == null)判断语句块，还未来得及往下执行，另一个线程也进入了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式 。</p>
<p><label style="color:red">结论：在实际开发中，不要使用这种方式。</label></p>
<h3 id="4-懒汉式-线程安全，同步方法"><a href="#4-懒汉式-线程安全，同步方法" class="headerlink" title="(4)懒汉式(线程安全，同步方法)"></a>(4)懒汉式(线程安全，同步方法)</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<p>优点：解决了线程安全的问题</p>
<p>缺点：效率太低，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return就行了。</p>
<p><label style="color:red">结论：在实际开发中，不推荐使用这种方式  </label></p>
<h3 id="5-懒汉式-同步代码块"><a href="#5-懒汉式-同步代码块" class="headerlink" title="(5)懒汉式(同步代码块)"></a>(5)懒汉式(同步代码块)</h3><p>提示：这种方法不能达到线程安全的目的，它是为了解决上一种方法效率太低的问题，所以把synchronized后置到判断条件上，之所以要提这种方式是为了引出下一种同时解决效率问题且线程安全的方法。（这种方法大家看看就行）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//执行到这里的时候，还是有可能转到另一个线程中执行，所以没有解决线程安全问题</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：<label style="color:red">这种方式不要在开发中使用！</label></p>
<h3 id="6-双重检查-效率高，线程安全"><a href="#6-双重检查-效率高，线程安全" class="headerlink" title="(6)双重检查(效率高，线程安全)"></a>(6)双重检查(效率高，线程安全)</h3><p>前两种方法都有问题，于是设计这种方法结合了上面两种方法的优点，第一效率高，第二线程安全。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//volatile关键字是一个轻量级的synchronized，它可以保证instance在内存中读取到的值是最新的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一次检查</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">               	<span class="comment">//第二次检查</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>（1）<label style="color:red">Double-Check（双重检查）</label>概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton  == null)检查，这样就可以保证线程安全了。  </p>
<p>（2)这样设计，实例化代码只用执行一次，后面再次访问时，判断if (singleton  == null)如果为false，直接 return实例化对象，也避免了反复进行方法同步。</p>
<p>结论：<label style="color:red">  线程安全；延迟加载；效率较高。在实际开发中，推荐使用这种单例设计模式 。</label></p>
<h3 id="7-静态内部类"><a href="#7-静态内部类" class="headerlink" title="(7)静态内部类"></a>(7)静态内部类</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写一个静态内部类,该类中有一个静态属性Singleton</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>（1）这种方式采用了类装载的机制来保证初始化实例时只有一个线程：</p>
<p><span class="github-emoji" alias="bulb" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8">&#x1f4a1;</span>静态内部类SingletonInstance在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成 Singleton的实例化。(妙啊<span class="github-emoji" alias="smiley" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8">&#x1f603;</span>）</p>
<p><span class="github-emoji" alias="bulb" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8">&#x1f4a1;</span>tip:  类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p>
<p>（2）结论：</p>
<p><label style="color:red">  避免了线程不安全，利用静态内部类特点实现延迟加载，效率高，推荐使用</label></p>
<h3 id="8-枚举"><a href="#8-枚举" class="headerlink" title="(8)枚举"></a>(8)枚举</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.INSTANCE();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就没了？？？ 是的这就没了。是不是so easy。</p>
<h4 id="补充：枚举类"><a href="#补充：枚举类" class="headerlink" title="补充：枚举类"></a>补充：枚举类</h4><p>JDK1.5中新增的枚举特性（没学过的小伙伴去巩固一下Java基础，这里不多说了，就简单的介绍一下）。枚举类是天然单例，是真正的final类，客户端不允许创建枚举类的实例，所以它是个单例。</p>
<p>那使用枚举类有啥好处呢？接下来你可能心里有一万个mmp。</p>
<p>我们在前面实现单例模式的时候，都把构造器私有化，这样可以防止客户端创建对象，那么构造器私有化真的能防止new出对象吗，我们来看下面的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获得反射CLASS对象</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">"singleton.test.Singleton"</span>);</span><br><span class="line">        <span class="comment">//获得构造器</span></span><br><span class="line">        Constructor constructor = c1.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//这个方法的参数设为true时，就会抑制Java的语法检查，它可以通过反射获得类的私有属性和私有方法（包括构造方法）</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Singleton instance = (Singleton) constructor.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Singleton对象在外部被创建了！！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供方法获得对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200713184811418.png" alt="image-20200713184811418"></p>
<p>What？？原来之前构造器私有化并不能防止new对象！（学过反射的同学应该知道，所以Java基础非常重要）</p>
<p><img src="/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200713190735455.png" alt="image-20200713190735455"></p>
<p>这就是为什么要使用过枚举实现单例模式的原因，它可以防御反射攻击与序列化和反序列化破坏，这种方式是Effective Java作者Josh Bloch提倡的方式 ，所以这种方式是单例模式的<label style="color:red">最佳实现方式。</label></p>
<p>结论：<label style="color:red">十分简单，极力推荐</label></p>
<h2 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h2><p>（1）JDK中，java.lang.Runtime就是经典的单例模式(饿汉式)。</p>
<p>源码如下：</p>
<p><img src="/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200713191014293.png" alt="image-20200713191014293"></p>
<p>（2）同样，在Spring中的bean的scope为singleton时，它也是很经典的单例模式，有兴趣的同学可以去研究下源码。</p>
<p>到此为止，单例设计模式就结束了，感谢您的阅读。</p>
<p><img src="/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200713191900364.png" alt="image-20200713191900364"></p>
<p>——————设计模式持续更新中。</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>单例模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-原型模式</title>
    <url>/2020/07/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="原型模式简介"><a href="#原型模式简介" class="headerlink" title="原型模式简介"></a>原型模式简介</h2><p>电脑上的复制粘贴功能我们都用过，将一个文件复制到另一个地方，这个文件和原来的文件没有一点差别，这其实就是原型模式的思想。在Java中，我们创建一个对象，以这个对象为原型，将这个对象的所有信息拷贝后创建另一个完全相同的对象，这就是所谓的原型设计模式。</p>
<p><img src="/2020/07/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20200722222742736.png" alt="image-20200722222742736"></p>
<a id="more"></a>

<h3 id="原型模式原理结构图"><a href="#原型模式原理结构图" class="headerlink" title="原型模式原理结构图"></a>原型模式原理结构图</h3><p><img src="/2020/07/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20200719152519784.png" alt="image-20200719152519784"></p>
<p>（1）Prototype(抽象原型类)：声明克隆方法的接口，是所有具体原型类的公共父类，它可是抽象类也可以是接口，甚至可以是具体实现类。</p>
<p>（2）ConcretePrototype(具体原型类)：它实现抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。</p>
<p>（3）Client(客户端)：在客户类中，让一个原型对象克隆自身从而创建一个新的对象。</p>
<h2 id="代码演示-克隆羊"><a href="#代码演示-克隆羊" class="headerlink" title="代码演示-克隆羊"></a>代码演示-克隆羊</h2><h3 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h3><p>我们来看这样一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, String color, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Sheep&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", color='"</span> + color + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很普通的羊类，有年龄、名字、颜色这三个属性，那么如果有一个需求，我们需要在客户端创建10只完全相同的羊，该怎么去做？最笨的方法就是这么去写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sheep sheep1 = <span class="keyword">new</span> Sheep(<span class="string">"Tom"</span>, <span class="string">"White"</span>, <span class="number">2</span>);</span><br><span class="line">        Sheep sheep2 = <span class="keyword">new</span> Sheep(sheep1.getName(), sheep1.getColor(), sheep1.getAge());</span><br><span class="line">        Sheep sheep3 = <span class="keyword">new</span> Sheep(sheep1.getName(), sheep1.getColor(), sheep1.getAge());</span><br><span class="line">        Sheep sheep4 = <span class="keyword">new</span> Sheep(sheep1.getName(), sheep1.getColor(), sheep1.getAge());</span><br><span class="line">        Sheep sheep5 = <span class="keyword">new</span> Sheep(sheep1.getName(), sheep1.getColor(), sheep1.getAge());</span><br><span class="line">        Sheep sheep6 = <span class="keyword">new</span> Sheep(sheep1.getName(), sheep1.getColor(), sheep1.getAge());</span><br><span class="line">        Sheep sheep7 = <span class="keyword">new</span> Sheep(sheep1.getName(), sheep1.getColor(), sheep1.getAge());</span><br><span class="line">        Sheep sheep8 = <span class="keyword">new</span> Sheep(sheep1.getName(), sheep1.getColor(), sheep1.getAge());</span><br><span class="line">        Sheep sheep9 = <span class="keyword">new</span> Sheep(sheep1.getName(), sheep1.getColor(), sheep1.getAge());</span><br><span class="line">        Sheep sheep10 = <span class="keyword">new</span> Sheep(sheep1.getName(), sheep1.getColor(), sheep1.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然这样的代码谁都不愿意去看到，那么我们就引出了原型设计模式，来看看原型模式是怎么实现的：</p>
<h3 id="原型模式改进"><a href="#原型模式改进" class="headerlink" title="原型模式改进"></a>原型模式改进</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, String color, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Sheep&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", color='"</span> + color + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object = <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Step1：首先我们将原来的Sheep类去实现Cloneable接口，点进这个接口我们会发现这是个空接口<img src="/2020/07/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20200719160924564.png" alt="image-20200719160924564"></p>
<p>一般空接口的作用都是起到标识的作用，例如实现了Serializable接口表示这个类可以被序列化，同样的道理，实现了Cloneable接口就表示这个类可以被克隆，不然就会报错。</p>
<p>Step2：然后重写Object类中clone方法，重写的核心代码就是调用父类Object的clone方法，这样就能去调用clone方法去复制对象了！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sheep sheep1 = <span class="keyword">new</span> Sheep(<span class="string">"Tom"</span>, <span class="string">"White"</span>, <span class="number">2</span>);</span><br><span class="line">        Sheep sheep2 = (Sheep)sheep1.clone();</span><br><span class="line">        System.out.println(<span class="string">"sheep1 = "</span> + sheep1);</span><br><span class="line">        System.out.println(<span class="string">"sheep2 = "</span> + sheep2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="/2020/07/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20200719162435377.png" alt="image-20200719162435377"></p>
<h3 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h3><p>在代码层面我们是已经实现了对象的复制，那么我们进一步思考，在sheep2中的各个属性，是直接引用原来sheep1中的各个属性的地址，还是sheep2中的属性是在内存中重新分配的呢？我们进行代码测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sheep sheep1 = <span class="keyword">new</span> Sheep(<span class="string">"Tom"</span>, <span class="string">"White"</span>, <span class="number">2</span>);</span><br><span class="line">        Sheep sheep2 = (Sheep)sheep1.clone();</span><br><span class="line">        System.out.println(sheep1.getName() == sheep2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2020/07/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20200719171009370.png" alt="image-20200719171009370"></p>
<p>我们发现sheep1和sheep2的name是同一块内存地址，也就是说sheep2并没有在内存中开辟新的空间给自己的name属性，而是引用原来sheep1的。查阅相关资料和自己实验的现象我们得出结论：</p>
<div class="note success">
            <p>如果原型对象的成员变量值的类型是八大基本类型(byte,short,int,long,char,double,float,boolean)，那么就直接复制，如果是复杂的类型，(枚举,String,对象)就只复制对应的内存地址。</p>
          </div>

<p>因此，我们引出了一个概念：<label style="color:#00CCFF">浅克隆</label>，也叫浅拷贝。顾名思义就是复制得很浅，都是引用原有的。</p>
<h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><p>和浅克隆对应的就是深克隆，所谓深克隆就是什么都是单独的，克隆出来的对象属性在内存中都是和原型对象属性不同的，它是一个崭新的克隆体！</p>
<p>浅克隆我们已经知道怎么实现了，下面我们来看看深克隆在代码中是怎样实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, String color, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Sheep&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", color='"</span> + color + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            object = ois.readObject();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>深克隆的实现方式就是采用对象的<label style="color:#00CCFF">序列化</label>和<label style="color:#00CCFF">反序列化</label>去实现的，在Sheep类中实现Serializable接口，在clone方法中序列化对象，再反序列化返回一个对象，那么这个对象就是崭新的克隆对象，这就完成了深克隆的功能，这块代码有问题或者有点了忘了的小伙伴可以回去复习一下Java基础。</p>
<p>我们来测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sheep sheep1 = <span class="keyword">new</span> Sheep(<span class="string">"Tom"</span>, <span class="string">"White"</span>, <span class="number">2</span>);</span><br><span class="line">        Sheep sheep2 = (Sheep)sheep1.clone();</span><br><span class="line">        System.out.println(sheep1.getName() == sheep2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2020/07/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20200719171053844.png" alt="image-20200719171053844"></p>
<p>显然sheep1和sheep2中name属性引用指向的是不同的内存地址，那么深克隆的实现就完成了！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1)创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。</p>
<p>2)不用重新初始化对象，而是动态地获得对象运行时的状态。</p>
<p>3)如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码。</p>
<p>4)在实现深克隆的时候可能需要比较复杂的代码。</p>
<p>5)缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了<label style="color:#00CCFF">ocp原则</label>，这点需要小伙伴们注意。</p>
<p>到此为止，原型设计模式就结束了，感谢您的阅读！</p>
<p><img src="/2020/07/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20200719172823582.png" alt="image-20200719172823582"></p>
<p>——————设计模式持续更新中。</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>原型模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-建造者模式</title>
    <url>/2020/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式又叫生成器模式，是一种对象构建模式。它将对象的创建过程和对象本身分离出来，注重创建的步骤，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p>
<p><img src="/2020/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200722222910395.png" alt="image-20200722222910395"></p>
<a id="more"></a>

<h3 id="建造者模式的四个角色"><a href="#建造者模式的四个角色" class="headerlink" title="建造者模式的四个角色"></a>建造者模式的四个角色</h3><p>1)  Product（产品角色）：一个具体的产品对象。  </p>
<p> 2)  Builder（抽象建造者）：创建一个 Product对象的各个部件指定的接口/抽象类。  </p>
<p> 3)  ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件。</p>
<p> 4)  Director（指挥者）：构建一个使用 Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作  用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。  </p>
<p>UML类图：</p>
<p><img src="/2020/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200722202815852.png" alt="image-20200722202815852"></p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>我们先来看这么一个需求：需要建一所房子：这一过程大致分为：打桩、砌墙、封顶。房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的，请编写程序，完成需求。  </p>
<h3 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h3><p>我们先来看下常规的写法，由这种写法来引出问题，我们接着再用建造者模式进行改进：</p>
<h4 id="首先定义一个抽象的房子类"><a href="#首先定义一个抽象的房子类" class="headerlink" title="首先定义一个抽象的房子类"></a>首先定义一个抽象的房子类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsHouse</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打地基</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//砌墙</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//该房顶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roof</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buildBasic();</span><br><span class="line">        buildWall();</span><br><span class="line">        roof();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="具体的房子"><a href="#具体的房子" class="headerlink" title="具体的房子"></a>具体的房子</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">AbsHouse</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子打地基"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子砌墙"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子盖房顶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();</span><br><span class="line">        commonHouse.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2020/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200722204037795.png" alt="image-20200722204037795"></p>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>我们先来看下传统写法的UML类图，这样可以清楚的了解整个设计的结构：</p>
<p><img src="/2020/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200722204545650.png" alt="image-20200722204545650"></p>
<p>首先这样设计虽然很简单，但是没有缓冲层，它把具体的房子(CommonHouse)和创建房子的具体流程耦合到了一起，这种设计方案耦合性太强，不好扩展和维护。我们理想的设计是将具体产品也就是房子和建造房子的具体流程给分开，这就需要建造者模式的思想，下面我们来看看该如何改进：</p>
<h2 id="建造者模式改进"><a href="#建造者模式改进" class="headerlink" title="建造者模式改进"></a>建造者模式改进</h2><p>UML类图：<img src="/2020/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200722205121671.png" alt="image-20200722205121671"></p>
<div class="note info">
            <p>分析：原先的类基本可以不变，但是增加了一个House类，这个类代表最终的产品，它可以根据具体房子的建造过程细节不同(过程步骤相同)，最终的类型也不同，房子最后都是房子，但不管小平房、大厦的建造步骤都是打地基、砌墙、封顶，只不过大厦的地基要打得更深等等；其次我们还增加了一个HouseDirector，这个类有很关键的作用，它起到解耦的作用，原先建造房子的过程是由具体的房子类完成，现在由HouseDirector这个指挥者完成，这个类因为聚合了HouseBuilder，而具体的房子类又继承于HouseBuilder，于是它就能调用建造房子的方法了，我们来看看具体的代码：</p>
          </div>

<h3 id="产品（房子）"><a href="#产品（房子）" class="headerlink" title="产品（房子）"></a>产品（房子）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象建造者-HouseBuilder"><a href="#抽象建造者-HouseBuilder" class="headerlink" title="抽象建造者(HouseBuilder)"></a>抽象建造者(HouseBuilder)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//组合房子类</span></span><br><span class="line">    House house = <span class="keyword">new</span> House();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打地基</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//砌墙</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该房顶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roof</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体房子"><a href="#具体房子" class="headerlink" title="具体房子"></a>具体房子</h3><p>小平房：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子打地基5m"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子砌墙"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子盖房顶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大厦：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargeBuilding</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"大厦打地基30m"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"大厦砌墙"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"大厦盖房顶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="指挥者-HouseDirector"><a href="#指挥者-HouseDirector" class="headerlink" title="指挥者(HouseDirector)"></a>指挥者(HouseDirector)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//聚合抽象房子建造者来使用具体房子的建造方法</span></span><br><span class="line">    HouseBuilder houseBuilder = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHouseBuilder</span><span class="params">(HouseBuilder houseBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">constructHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        houseBuilder.buildBasic();</span><br><span class="line">        houseBuilder.buildWall();</span><br><span class="line">        houseBuilder.roof();</span><br><span class="line">        System.out.println(<span class="string">"房子建造完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"===================================="</span>);</span><br><span class="line">        <span class="keyword">return</span> houseBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端-Client"><a href="#客户端-Client" class="headerlink" title="客户端(Client)"></a>客户端(Client)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//普通房子</span></span><br><span class="line">        HouseDirector houseDirector = <span class="keyword">new</span> HouseDirector(<span class="keyword">new</span> CommonHouse());</span><br><span class="line">        House commonHouse = houseDirector.constructHouse();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//复用HouseDirector建造大厦</span></span><br><span class="line">        houseDirector.setHouseBuilder(<span class="keyword">new</span> LargeBuilding());</span><br><span class="line">        House LB = houseDirector.constructHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<img src="/2020/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200722213045775.png" alt="image-20200722213045775"></p>
<p>因为在上面已经分析过了，这里就不再进行具体的代码分析了。我们可以发现，最为核心的一个类时<label style="color:#00FFCC">HouseDiretor</label>这个类，它制定了建造房子的具体步骤，同时还把具体的房子给返回了，也就是说这个类是实现建造过程和产品本身解耦的关键。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note success">
            <p>1)客户端(使用程序)不必知道产品内部组成的细节，<label style="color:#00FFCC">将产品本身与产品的创建过程解耦</label>，使得相同的创建过程可以创建不同的产品对象。</p><p>2)<label style="color:#00FFCC">每一个具体建造者都相对独立</label>，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具  体建造者，用户使用不同的具体建造者即可得到不同的产品对象。</p><p>3)可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 </p><p>4)增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合<label style="color:#00FFCC">“开闭原则”。</label> </p><p>5)建造者模式所创建的<label style="color:#00FFCC">产品一般具有较多的共同点，其组成部分相似，</label> 如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。  </p><p>6)如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式。</p><p>7)抽象工厂模式VS建造者模式  </p><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p>
          </div>

<p>到此为止，建造者模式就结束了，感谢您的观看。</p>
<p><img src="/2020/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200722215152406.png" alt="image-20200722215152406"></p>
<p>——————设计模式持续更新中</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>建造者模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-桥接模式</title>
    <url>/2020/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="桥接模式简介"><a href="#桥接模式简介" class="headerlink" title="桥接模式简介"></a>桥接模式简介</h2><p>桥接模式基于类的最小设计原则，通过封装、继承、聚合等方式让不同的类承担不同的职责，它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展，它是一种结构型模式。</p>
<p><img src="/2020/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20200731170106784.png" alt="image-20200731170106784"></p>
<a id="more"></a>

<h3 id="桥接模式原理类图"><a href="#桥接模式原理类图" class="headerlink" title="桥接模式原理类图"></a>桥接模式原理类图</h3><p><img src="/2020/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20200731144026899.png" alt="image-20200731144026899"></p>
<p>1) Client类：桥接模式的调用者</p>
<p>2) Abstraction：抽象类，维护了Implementor以及它的实现类，充当桥接类</p>
<p>3) RefinedAbstraction：是Abstraction抽象类的实现子类  </p>
<p>4) Implementor :行为实现类的接口  </p>
<p>5) ConcreteImplementorA/B：行为的具体实现类   </p>
<h4 id="原理类图分析"><a href="#原理类图分析" class="headerlink" title="原理类图分析"></a>原理类图分析</h4><p>这里的Abstraction抽象类中聚合了Implementor，它们两者是调用者与被调用者的关系，也就是具体的子类RefinedAbstraction去调用ConcreteImplementor中实现的方法，其中Abstraction抽象类就充当了桥的作用，如图所示：</p>
<p><img src="/2020/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20200731145940727.png" alt="image-20200731145940727"></p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>假设我们要买一个手机，手机有各种各样的牌子，还有不同的配置，配置我们这里简单的设为内存，那么按照传统的思路，我们会这样去设计：</p>
<p><img src="/2020/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20200731155217480.png" alt="image-20200731155217480"></p>
<p>这样设计的弊端就是会产生非常多的类，假设现在又有12G的内存，那就要增加一个HuaWei&amp;12G类，如果要增加一个品牌，那么又会产生一系列的手机类。</p>
<p><img src="/2020/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20200731155608414.png" alt="image-20200731155608414"></p>
<p>传统设计方案弊端：类爆炸。</p>
<h3 id="桥接模式改进"><a href="#桥接模式改进" class="headerlink" title="桥接模式改进"></a>桥接模式改进</h3><p>分析：在这个需求中，我们可以发现，手机其实是有两个维度的，一个维度是手机的品牌，另一个就是内存，那么我们就能用桥接模式将一个维度抽象出来，让另一个类间接得去使用而不是单独的使用继承，那么类爆炸的问题就解决了。在很多设计模式中都应用到这种思想，<label style="color:#00CCFF">采用聚合或者组合的方式代替继承。</label>我们先来看看UML类图：</p>
<p><img src="/2020/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20200731161218239.png" alt="image-20200731161218239"></p>
<p>具体代码如下：</p>
<h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addMemory</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory6G</span> <span class="keyword">implements</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory8G</span> <span class="keyword">implements</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Phone"><a href="#Phone" class="headerlink" title="Phone"></a>Phone</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Memory memory;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(Memory memory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buyPhone</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWei</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"购买了华为手机，内存为："</span> + memory.addMemory() + <span class="string">"G"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HuaWei huaWei = <span class="keyword">new</span> HuaWei();</span><br><span class="line">        huaWei.setMemory(<span class="keyword">new</span> Memory8G());</span><br><span class="line">        huaWei.buyPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行一把：</p>
<p><img src="/2020/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20200731161422251.png" alt="image-20200731161422251"></p>
<p>假设我们现在又有一个扩展的需求，增加一个Vivo的手机内存为8G，我们只需要简单的增加一个Vivo类去实现Phone类即可，而传统的设计方案要增加两个类，而且代码的耦合性很高。所以桥接模式的优点就提现出来了。</p>
<h2 id="桥接模式在JDBC中的应用"><a href="#桥接模式在JDBC中的应用" class="headerlink" title="桥接模式在JDBC中的应用"></a>桥接模式在JDBC中的应用</h2><p>我们在JDBC中，会使用DriverManager这个类去调用getConnection方法拿到Connection的实例对象，那么从桥接模式的角度看，DriverManager其实就是抽象层，只不过它的下层没有具体的实现类，所以它不是抽象类而是一个普通类，它依赖了Connection这个接口，在这个接口下又有接口去继承了它，再下一层才是具体的实现类，类图如下：</p>
<p><img src="/2020/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20200731163039823.png" alt="image-20200731163039823"></p>
<p>对比例子：这里的DriverManager其实就相当于上面例子的具体手机类，而Connection这个接口就相当于手机的内存，手机有不同的内存，Connection也有不同的数据库连接，有Oracle的，有MySql的，以及各种公司不同的连接。</p>
<div class="note info">
            <p>在这个类图中我们可以发现，它跟我们上面的例子有些许的不同，DriverManager不是一个抽象类，Connection接口抽象了两层，这是很正常的，JDK中运用了大量的设计模式，但是跟我们传统的设计模式有略微的不同，但是基本思想是一致的，所以我们要把思维扩散开来，不要照搬传统的设计模式，因为<label style="color:#00CCFF">设计模式是一种思想，</label>而不是死板的代码。</p>
          </div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note success">
            <p>1)桥接模式实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。  </p><p>2)对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。  </p><p>3)桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。  </p>
          </div>

<div class="note danger">
            <p>我之前说过，没有绝对完美的设计模式，设计模式只是在不同使用场景中能够很好的代替传统的设计。</p><p>缺点：桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。  </p>
          </div>

<p>桥接模式应用场景：桥接模式要求正确识别出系统中两个独立变化的维度(抽象、和实现)，因此其使用范围有一定的局限性，即需  </p>
<p>要有这样的应用场景。</p>
<p>到此为止，桥接模式就结束了，感谢您的阅读~</p>
<p><img src="/2020/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20200731170138300.png" alt="image-20200731170138300"></p>
<p>——————设计模式持续更新中</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>桥接模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-组合模式</title>
    <url>/2020/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="组合模式简介"><a href="#组合模式简介" class="headerlink" title="组合模式简介"></a>组合模式简介</h2><p>组合模式又叫部分整体模式，它创建了对象组的<label style="color:#00FFCC">树形结构</label>，将对象组合成树状结构来表示”整体—部分”的层次关系，属于结构性模式。</p>
<p><img src="/2020/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200806170623214.png" alt="image-20200806170623214"></p>
<a id="more"></a>

<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>有一个学校院系展示需求，在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。如图：</p>
<p><img src="/2020/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200806152047306.png" alt="image-20200806152047306"></p>
<h3 id="传统解决方案"><a href="#传统解决方案" class="headerlink" title="传统解决方案"></a>传统解决方案</h3><p>将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的，如图所示<img src="/2020/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200806152000387.png" alt="image-20200806152000387"></p>
<p>问题：这样的设计结构其实不太符合需求，实际上我们的要求是：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，不能很好实现的管理的操作，比如对学院、系的添加，删除，遍历等。   </p>
<p>解决方案：把学校、院、系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现管理操作，由此引出组合模式。</p>
<h3 id="组合模式改进"><a href="#组合模式改进" class="headerlink" title="组合模式改进"></a>组合模式改进</h3><p>组合模式可以使用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象。</p>
<h4 id="原理类图"><a href="#原理类图" class="headerlink" title="原理类图"></a>原理类图</h4><p>  <img src="/2020/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200806152831471.png" alt="image-20200806152831471"></p>
<p>角色分析：</p>
<p>(1) Component：这是组合中对象声明接口，它为其实现子类提供默认的操作方法，如增删改等方法，用于访问和管理子部件。</p>
<p>(2) Leaf ：在组合中表示叶子节点，叶子节点没有子节，是最下层的节点，因此不能操作其它节点。</p>
<p>(3) Composite：非叶子节点，用于存储子部件(聚合的方式)，子部件可以是其它Composite也可以是Leaf ，它实现了Component接口中的相关方法。</p>
<h4 id="组合模式解决学校院系展示的应用实例"><a href="#组合模式解决学校院系展示的应用实例" class="headerlink" title="组合模式解决学校院系展示的应用实例"></a>组合模式解决学校院系展示的应用实例</h4><p>首先设计UML类图：</p>
<p><img src="/2020/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200806153851612.png" alt="image-20200806153851612"></p>
<p>分析：其中的University就是Composite，它的子部件是College和Department，College也是Composite，Department属于最底层的节点，是Leaf。</p>
<p>具体代码如下：</p>
<h5 id="OrganizationComponent"><a href="#OrganizationComponent" class="headerlink" title="OrganizationComponent"></a>OrganizationComponent</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String des;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrganizationComponent</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> des;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的add和remove方法都做成默认的空实现，抛出一个不支持方法的异常即可，print方法做成抽象，由其子类实现。</p>
<h5 id="University"><a href="#University" class="headerlink" title="University"></a>University</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">University</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;OrganizationComponent&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">University</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,des);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">        list.add(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">        list.remove(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------"</span> + getName() + <span class="string">"---------"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent organizationComponent : list) &#123;</span><br><span class="line">            organizationComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的List集合放置节点部件，就是College和Department，print方法通过for循环遍历节点并调用print方法完成打印</p>
<h5 id="College"><a href="#College" class="headerlink" title="College"></a>College</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">College</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;OrganizationComponent&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">College</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,des);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">        list.add(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">        list.remove(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------"</span> + getName() + <span class="string">"---------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent organizationComponent : list) &#123;</span><br><span class="line">            organizationComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为都是Composite，所以和University相同，但是将来实际业务中，Colleage的add 和University的add或者其他方法不一定完全一样</p>
<h5 id="Department"><a href="#Department" class="headerlink" title="Department"></a>Department</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,des);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为它是非叶子节点，所以remove和add方法都不用重写了，它下面没有节点提供给它进行操作</p>
<h5 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先创建学校</span></span><br><span class="line">        OrganizationComponent university = <span class="keyword">new</span> University(<span class="string">"清华大学"</span>, <span class="string">"中国顶尖大学"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建学院</span></span><br><span class="line">        OrganizationComponent computerCollege = <span class="keyword">new</span> College(<span class="string">"计算机学院"</span>, <span class="string">"清华大学计算机学院"</span>);</span><br><span class="line"></span><br><span class="line">        OrganizationComponent infoEngineercollege = <span class="keyword">new</span> College(<span class="string">"信息工程学院"</span>, <span class="string">" 清华大学信息工程学院"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建各个学院下面的系(专业)</span></span><br><span class="line">        computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"软件工程系"</span>, <span class="string">"软件工程不错"</span>));</span><br><span class="line">        computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"网络工程系"</span>, <span class="string">"网络工程不错"</span>));</span><br><span class="line">        computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"计算机科学与技术系"</span>, <span class="string">"计算机科学与技术是老牌的专业"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">"通信工程系"</span>, <span class="string">"通信工程不好学"</span>));</span><br><span class="line">        infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">"信息工程系"</span>, <span class="string">"信息工程好学"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将学院加入到学校</span></span><br><span class="line">        university.add(computerCollege);</span><br><span class="line">        university.add(infoEngineercollege);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//university.print();</span></span><br><span class="line">        university.print();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行一把：<img src="/2020/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200806162718071.png" alt="image-20200806162718071"></p>
<h2 id="组合模式在JDK中的应用"><a href="#组合模式在JDK中的应用" class="headerlink" title="组合模式在JDK中的应用"></a>组合模式在JDK中的应用</h2><p>Java的集合类HashMap就使用了组合模式</p>
<p>类图</p>
<p><img src="/2020/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200806164032487.png" alt="image-20200806164032487"></p>
<p>其中Map就是Component<img src="/2020/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200806163945886.png" alt="image-20200806163945886"></p>
<p>HashMap就是Composite，只不过抽象了两层，它的上层有AbstractHashMap<img src="/2020/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200806164201052.png" alt="image-20200806164201052"></p>
<p>Node就是叶子节点Leaf，它是组合在HashMap中的一个静态内部类<img src="/2020/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200806164446949.png" alt="image-20200806164446949"></p>
<p>还是原来那句话，设计模式略有差异很正常，设计思想都是一样的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note success">
            <p>优点：</p><p>1)简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。 </p><p>2)具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动。</p><p>3)方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构。  </p>
          </div>

<div class="note danger">
            <p>不足：</p><p>1)需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式。</p><p>2)要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式。  </p>
          </div>



<p>到此为止，组合模式就结束了，感谢您的阅读~</p>
<p><img src="/2020/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200806170740819.png" alt="image-20200806170740819"></p>
<p>——————设计模式持续更新中</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>组合模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-装饰者模式</title>
    <url>/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="装饰者模式简介"><a href="#装饰者模式简介" class="headerlink" title="装饰者模式简介"></a>装饰者模式简介</h2><p>装饰者模式是将新功能动态的附加到对象上，在对象功能扩展方面，它比继承更有弹性，装饰者模式很好得体现了开闭原则(ocp)。  </p>
<p><img src="/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200801174019582.png" alt="image-20200801174019582"></p>
<a id="more"></a>

<h2 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h2><p>现在有一个星巴克咖啡订单项目，具体需求如下：</p>
<p>1) 咖啡种类/单品咖啡有：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)</p>
<p>2) 调料有：Milk(牛奶)、Soy(豆浆)、Chocolate(摩卡)</p>
<p>要求：(1)在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便。(2)使用OO的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组。(3设计两个方法，一个方法计算价格，另一个方法打印出咖啡的描述。</p>
<h3 id="传统设计方案"><a href="#传统设计方案" class="headerlink" title="传统设计方案"></a>传统设计方案</h3><p>如果使用传统的设计，UML类图如下：</p>
<p><img src="/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200801144342633.png" alt="image-20200801144342633"></p>
<p>这样设计的缺点就是类爆炸，各种单品咖啡和调料组合过多，产生的类就会程爆炸式增长，不利于代码的维护和扩展。</p>
<p>网上有一张图很形象的提现出了”类爆炸”：</p>
<p><img src="/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200801144828972.png" alt="image-20200801144828972"></p>
<p>这样的设计显然不合理，于是有人对这个方案进行了改进：</p>
<h3 id="方案改进"><a href="#方案改进" class="headerlink" title="方案改进"></a>方案改进</h3><p>前面分析到方案1因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到Drink类，这样就不会造成类数量过多。从而提高项目的维护性(如图)</p>
<p><img src="/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200801145027057.png" alt="image-20200801145027057"></p>
<p>但是这样设计也有缺点，当我们要增加一种调料时，就会在超类Drink中新增一个属性，如果调料的价格发生改变，我们原有的代码cost方法进行修改，显然这样违背了<label style="color:#00CCFF">开闭原则。</label></p>
<p>这两种方案都不能很好地满足项目需求，于是就有了装饰者模式，它可以同时解决类爆炸和满足OCP原则。</p>
<h2 id="装饰者模式改进"><a href="#装饰者模式改进" class="headerlink" title="装饰者模式改进"></a>装饰者模式改进</h2><p>原理图：</p>
<p><img src="/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200801165735897.png" alt="image-20200801165735897"></p>
<p>1) Component：主体：比如类似前面的Drink  </p>
<p>2) ConcreteComponent：具体的主体，比如前面的各个单品咖啡  </p>
<p>3) Decorator：装饰者，比如各调料</p>
<p>装饰者模式就像打包一个快递，主体：比如：陶瓷、衣服 (Component) ；被装饰者：包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)  </p>
<p>tip：在如图的Component与 ConcreteComponent之间，如果 ConcreteComponent类很多，还可以设计一个缓冲层，将共有的部分提取出来，抽象成一个类。  </p>
<p><img src="/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200801153712296.png" alt="image-20200801153712296"></p>
<p>项目结构：<img src="/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200801161351708.png" alt="image-20200801161351708"></p>
<p>代码如下：</p>
<h3 id="Drink"><a href="#Drink" class="headerlink" title="Drink"></a>Drink</h3><p>首先设计Drink这个超类，所有的类都依赖于这个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String des;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里留一个抽象的cost方法，让子类去实现并计算总的费用</p>
<h3 id="咖啡类去继承Drink类"><a href="#咖啡类去继承Drink类" class="headerlink" title="咖啡类去继承Drink类"></a>咖啡类去继承Drink类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffe</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计四种咖啡去继承Coffee类"><a href="#设计四种咖啡去继承Coffee类" class="headerlink" title="设计四种咖啡去继承Coffee类"></a>设计四种咖啡去继承Coffee类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeCaf</span> <span class="keyword">extends</span> <span class="title">Coffe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeCaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setDes(<span class="string">"无因咖啡"</span>);</span><br><span class="line">        setPrice(<span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Espresso</span> <span class="keyword">extends</span> <span class="title">Coffe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Espresso</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setDes(<span class="string">"意式浓缩"</span>);</span><br><span class="line">        setPrice(<span class="number">6.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongBlack</span> <span class="keyword">extends</span> <span class="title">Coffe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setDes(<span class="string">"美式LongBlack"</span>);</span><br><span class="line">        setPrice(<span class="number">5.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortBlack</span> <span class="keyword">extends</span> <span class="title">Coffe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShortBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setDes(<span class="string">"美式ShortBlack"</span>);</span><br><span class="line">        setPrice(<span class="number">4.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计装饰者类-Decorator"><a href="#设计装饰者类-Decorator" class="headerlink" title="设计装饰者类(Decorator)"></a>设计装饰者类(Decorator)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Drink obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + obj.cost();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的cost方法设计得很巧妙，运用了递归的思想，会在下面做详细的分析</p>
<h3 id="设计三种具体的装饰者-调料"><a href="#设计三种具体的装饰者-调料" class="headerlink" title="设计三种具体的装饰者(调料)"></a>设计三种具体的装饰者(调料)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> decorator.Drink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chocolate</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Chocolate</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(obj);</span><br><span class="line">		setDes(<span class="string">"巧克力"</span>);</span><br><span class="line">		setPrice(<span class="number">3.0f</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> decorator.Drink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(obj);</span><br><span class="line">      setDes(<span class="string">"牛奶"</span>);</span><br><span class="line">      setPrice(<span class="number">2.0f</span>); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> decorator.Drink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soy</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Soy</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(obj);</span><br><span class="line">      setDes(<span class="string">"豆汁"</span>);</span><br><span class="line">      setPrice(<span class="number">1.5f</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，基于装饰者模式所有的类都设计好了，我们用客户端进行测试。</p>
<h3 id="咖啡店"><a href="#咖啡店" class="headerlink" title="咖啡店"></a>咖啡店</h3><p>假设现在有一个订单，需要一杯LongBlack加一分牛奶和一份巧克力</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeBar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Drink order = <span class="keyword">new</span> LongBlack();</span><br><span class="line">		order.cost();</span><br><span class="line">		System.out.println(<span class="string">"单品咖啡费用 = "</span> + order.cost());</span><br><span class="line">		System.out.println(<span class="string">"描述 = "</span> + order.getDes());</span><br><span class="line">        </span><br><span class="line">		order = <span class="keyword">new</span> Milk(order);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"order 加入一份牛奶 费用 = "</span> + order.cost());</span><br><span class="line">		System.out.println(<span class="string">"order 加入一份牛奶 当前添加 = "</span> + order.getDes());</span><br><span class="line"></span><br><span class="line">		order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line">        System.out.println(<span class="string">"order 加入一份牛奶和一份巧克力 费用 = "</span> + order.cost());</span><br><span class="line">		System.out.println(<span class="string">"order 加入一份牛奶和一份巧克力 当前添加 = "</span> + order.getDes());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200801163238642.png" alt="image-20200801163238642"></p>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>在上面设计Decorator的时候提到过其中的cost方法运用了递归的思想，这里做一下详细的分析：</p>
<p>第一次new了一杯单品咖啡LongBlack没有问题，具体看这行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">order = <span class="keyword">new</span> Milk(order);</span><br></pre></td></tr></table></figure>

<p>那我们在加入一份牛奶时，创建了Milk对象并把之前的LongBlack传给了它构造器，于是Milk对象中的obj就是LongBlack，这时调用cost方法，首先执行super.getPrice()得到牛奶的价格为2元，再执行obj.cost()方法，此时的obj就是LongBlack为5元，那么第一次的费用就是7元。到目前为止，还没有用到递归，在第二次加入巧克力时，会执行这行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">order = <span class="keyword">new</span> Chocolate(order);</span><br></pre></td></tr></table></figure>

<p>我们又把原来的order传给了chocolate，这时的order为Milk对象，再去调用cost方法，此时super.getPrice()得到巧克力的价格为3元，重点来了，执行obj.cost()方法，此时的obj也就是Milk对象会再次进入到它的cost方法，又会去执行super.getPrice()和obj.cost()，而这个obj就是原先保存在Milk中的LongBlack，于是就完成了最终的费用计算。</p>
<p><img src="/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200801165239931.png" alt="image-20200801165239931"></p>
<h2 id="装饰者模式对比桥接模式"><a href="#装饰者模式对比桥接模式" class="headerlink" title="装饰者模式对比桥接模式"></a>装饰者模式对比桥接模式</h2><p>看过我前面写的桥接模式的小伙伴应该会发现这两种设计模式十分相像，好像都是将一个产品拆分成两个，我们对比一下类图：</p>
<p><img src="/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200801170109230.png" alt="image-20200801170109230"></p>
<p>对比一下可以发现，主体部分都是抽象类，但区别在，桥接模式的行为实现者是被聚合到抽象类中，它们两者之间没有继承关系，而装饰者模式是将抽象类聚合到装饰者中，并且他们存在继承关系。网上有大佬总结出来两点：</p>
<div class="note info">
            <p>1、桥接模式中所说的分离，其实是指将结构与实现分离（当结构和实现有可能发生变化时）或属性与基于属性的行为进行分离；而装饰者只是对基于属性的行为进行封闭成独立的类。</p><p>2、桥接中的行为是横向的行为，行为彼此之间无关联；而装饰者模式中的行为具有可叠加性，其表现出来的结果是一个整体，一个各个行为组合后的一个结果。</p>
          </div>

<p>我觉得这样的总结对我来说不是很清晰，可能每个人的理解不同，这也很正常。</p>
<p>但是以我的理解，它们最大的差异在于聚合的方向，谁聚合了一个类，谁就是主体，所以装饰者模式的重点就是装饰者，桥接模式的重点就是抽象类的实现子类。（可能说法不太严谨，见谅）</p>
<h2 id="装饰者模式在JDK中的应用"><a href="#装饰者模式在JDK中的应用" class="headerlink" title="装饰者模式在JDK中的应用"></a>装饰者模式在JDK中的应用</h2><p>在JDK中，IO流就运用了装饰者模式：<br><img src="/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200801171606941.png" alt="image-20200801171606941"></p>
<p>代码说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"d:\\abc.txt"</span>));</span><br><span class="line">        System.out.println(dis.read());</span><br><span class="line">        dis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  说明 ：</p>
<div class="note success">
            <p>1、InputStream是抽象类,类似我们前面讲的Drink  </p><p>2、FileInputStream是InputStream子类，类似我们前面的DeCaf,  LongBlack </p><p>3、FilterInputStream是InputStream子类：类似我们前面的Decorator修饰者  </p><p>4、DataInputStream是FilterInputStream子类，具体的修饰者，类似前面的Milk, Soy等  </p><p>5、FilterInputStream类有protected volatile InputStream in 属性，即含有被装饰者</p><p>分析得出在jdk的io体系中，就是使用装饰者模式</p>
          </div>

<p>到此为止，装饰者模式就结束了，感谢您的阅读~</p>
<p><img src="/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200801173901708.png" alt="image-20200801173901708"></p>
<p>——————设计模式持续更新中</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>装饰者模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-适配器模式</title>
    <url>/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="适配器模式简介"><a href="#适配器模式简介" class="headerlink" title="适配器模式简介"></a>适配器模式简介</h2><p>适配器模式是将某个类的接口转换成客户端期望的另一个接口，主要目的是兼容，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper) 。适配器模式又可以细分为类适配器模式、对象适配器模式和接口适配器模式。</p>
<p><img src="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20200728190722200.png" alt="image-20200728190722200"></p>
<a id="more"></a>

<h3 id="真实世界类比"><a href="#真实世界类比" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p>每个国家电源的插座都有不同的标准，如果要出国，可能会出现自己的适配器和别的国家插座接口不匹配的情况，因此有了多功能转换插头，它就充当了适配器的作用。</p>
<p><img src="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20200728171152443.png" alt="image-20200728171152443"></p>
<h3 id="实际开发"><a href="#实际开发" class="headerlink" title="实际开发"></a>实际开发</h3><p>假设我们在做一套股票看盘系统，数据提供方给我们提供 XML 格式数据，我们获取数据用来显示，随着系统的迭代，我们要整合一些第三方系统的对外数据，但是他们只提供获取 JSON 格式的数据接口。</p>
<p>在不想改变原有代码逻辑的情况下，如何解决呢？</p>
<p>这时候我们就可以创建一个「适配器」。这是一个特殊的对象， 能够转换对象接口， 使其能与其他对象进行交互。</p>
<p>适配器模式通过封装对象将复杂的转换过程隐藏于幕后。 被封装的对象甚至察觉不到适配器的存在。</p>
<p><img src="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20200728171424195.png" alt="image-20200728171424195"></p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>我们以生活中充电为案例，来看看适配器是如何解决电压不兼容的问题。假设我们的手机充电需要的电压为5V，而插座提供给我们的电压为220V电压，那么手机的电源适配器就充当了适配器角色，它将电压降压后我们才能正常充电。</p>
<p>思路分析：</p>
<p>我们先设计出UML类图：<img src="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20200728172230682.png" alt="image-20200728172230682"></p>
<p>这种设计方式是类适配器模式，最大的特点就是有继承关系，我们来看看具体的代码：</p>
<h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><h4 id="Voltage220V-标准电压"><a href="#Voltage220V-标准电压" class="headerlink" title="Voltage220V(标准电压)"></a>Voltage220V(标准电压)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">"电压为"</span> + scr + <span class="string">"伏"</span>);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Voltage5V-需要的电压"><a href="#Voltage5V-需要的电压" class="headerlink" title="Voltage5V(需要的电压)"></a>Voltage5V(需要的电压)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="VoltageAdapter-适配器"><a href="#VoltageAdapter-适配器" class="headerlink" title="VoltageAdapter(适配器)"></a>VoltageAdapter(适配器)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = output220V();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dst = v/<span class="number">44</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"适配器转换电压5V"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Phone-手机"><a href="#Phone-手机" class="headerlink" title="Phone(手机)"></a>Phone(手机)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(Voltage5V v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = v.output5V();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"电压符合，进行充电"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"电压不符合，无法充电"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Client-客户端"><a href="#Client-客户端" class="headerlink" title="Client(客户端)"></a>Client(客户端)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行一把：<img src="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20200728174855214.png" alt="image-20200728174855214"></p>
<h5 id="类适配器模式分析"><a href="#类适配器模式分析" class="headerlink" title="类适配器模式分析"></a>类适配器模式分析</h5><p>在适配器类(VoltageAdapter)中继承了Voltage220V，我们知道一旦使用了继承，代码的耦合性就会增加，所以这算是一个缺点。但是它可以根据需求去重写里面的方法，这也是优点，所以有利也有弊。还有一点就是Voltage220V中的方法会在适配器类中暴露出来，这样增加了使用的成本。</p>
<h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><p>(1)基本思路和类的适配器模式相同，只是将适配器类作修改，不是继承Voltage220V类，而是持有它的实例，以解决兼容性的问题。  </p>
<p>(2)根据<label style="color:#00FFCC">“合成复用原则”</label>，在系统中尽量使用关联关系（聚合或组合）来替代继承关系。</p>
<p>(3)对象适配器模式是适配器模式常用的一种。</p>
<p>类图：<img src="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20200728175826681.png" alt="image-20200728175826681"></p>
<p>代码实现：</p>
<p>其他不变，我们对适配器类稍作修改：</p>
<h4 id="改进VoltageAdapter"><a href="#改进VoltageAdapter" class="headerlink" title="改进VoltageAdapter"></a>改进VoltageAdapter</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Voltage220V voltage220V = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.voltage220V = voltage220V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dst = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != voltage220V) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = voltage220V.output220V();</span><br><span class="line"></span><br><span class="line">            dst = v/<span class="number">44</span>;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"使用对象适配器，进行适配~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> VoltageAdapter(<span class="keyword">new</span> Voltage220V()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行一下：<img src="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20200728180657117.png" alt="image-20200728180657117"></p>
<h5 id="对象适配器模式分析"><a href="#对象适配器模式分析" class="headerlink" title="对象适配器模式分析"></a>对象适配器模式分析</h5><p>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。  </p>
<p>根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承Voltage220V的局限性问题，也不再要求Voltage5V必须是接口。</p>
<h5 id="总结：使用成本更低，更灵活。"><a href="#总结：使用成本更低，更灵活。" class="headerlink" title="总结：使用成本更低，更灵活。"></a>总结：使用成本更低，更灵活。</h5><h3 id="接口适配器模式"><a href="#接口适配器模式" class="headerlink" title="接口适配器模式"></a>接口适配器模式</h3><p>(这里讲接口适配器模式跟上面的案例没有关系)</p>
<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>接口适配器模式在窗体界面中应用最为广泛，在安卓中，我们添加监听器时，通常这个监听器需要实现一个接口，而这个接口中一般会有非常多的方法，假如有100个方法，但是我们只需要用到其中一两个，那么有没有办法可以不去实现这个接口的全部方法，而只去重写我们需要的那几个方法？接口适配器模式就能实现。</p>
<h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>在java的awt中，如果我们想要关闭一个窗口，需要去添加WindowListener监听器，而这个监听器中有如下几个方法需要我们去实现：</p>
<p><img src="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20200728184104644.png" alt="image-20200728184104644"></p>
<p>但是我们只想用windowClosing这个方法，这时我们就可以用WindowAdapter这个类，我们来看看这个类的源码：</p>
<p><img src="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20200728184247354.png" alt="image-20200728184247354"></p>
<p>首先它是个抽象类，实现了WindowListener等接口中的方法，但都是空实现：</p>
<p><img src="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20200728184353917.png" alt="image-20200728184353917"></p>
<p>因此，当我们new一个WindowAdapter的匿名类时，就可以选择性的去实现其中的方法，这就是典型的接口适配器模式。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>(1)适用于一个接口不想使用其所有的方法的情况下使用。</p>
<p>(2)配合匿名类一起使用。</p>
<h3 id="适配器模式在Spring中的应用"><a href="#适配器模式在Spring中的应用" class="headerlink" title="适配器模式在Spring中的应用"></a>适配器模式在Spring中的应用</h3><p>  SpringMVC中的DispatchServlet在处理请求时，会使用HandlerAdapter，它就使用了适配器模式。关于详细的源码分析因为太多了将在后续的专题更新~~</p>
<p>到此为止，适配器模式就结束了，感谢您的阅读~</p>
<p><img src="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20200728191213166.png" alt="image-20200728191213166"></p>
<p>——————设计模式持续更新中</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>适配器模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
