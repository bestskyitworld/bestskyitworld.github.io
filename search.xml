<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>改变，就是好事</title>
    <url>/2020/07/11/%E6%94%B9%E5%8F%98%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%A5%BD%E4%BA%8B/</url>
    <content><![CDATA[<p>从小到大，我们听过也看过很多大道理，各种励志的鸡汤也看得不少，但是真正因此付出行动的少之又少，或者大多数时候，都是三分钟热度，还没坚持几天，便放弃了。到最后你会发现，道理你都懂，想的也很多，但做的却太少。</p>
<p><img src="/2020/07/11/%E6%94%B9%E5%8F%98%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%A5%BD%E4%BA%8B/image-20200712160418744.png" alt="image-20200712160418744"></p>
<a id="more"></a>

<h2 id="我们之所以这样，是因为缺少特殊的时期和境遇"><a href="#我们之所以这样，是因为缺少特殊的时期和境遇" class="headerlink" title="我们之所以这样，是因为缺少特殊的时期和境遇"></a>我们之所以这样，是因为缺少特殊的时期和境遇</h2><p>不要指望自己突然某天变得很自律，早睡早起锻炼身体，仅仅是因为看了一些狗血鸡汤，那显然不现实；你也不要指望自己突然某天变得热爱学习，每天看书刷题，仅仅是因为看了一些TED的演讲，把你说得热血沸腾。但这些你也不用责怪自己，因为如果你有这个觉悟，你早就已经改变了，你现在的一些习惯和行为，都是基于你过去这么多年累积下来的；当然如果你内心真的十分渴望改变，凭借你强大的意志力，是可以做到的，但大多数情况是，你的意志力十分薄弱。</p>
<p>再举个例子，人们总说要珍惜眼前的一切，但是如果你没有经历过家人朋友意外的离去，你又怎么会特别小心的珍惜跟他们在一起的时间。你没有注意到父母早已经有了皱纹和白发，身体已经一天不如一天，所以你还总是去跟他们吵架。</p>
<p>所以一个人成长和改变很多时候都不是主动，而是被动的。一个人如果从小到大家庭环境都很优越，那么他很可能就是从小玩大，他的观念一定不是好好学习，将来考上好的大学才好赚钱，因为他明白家里有的是钱，但是如果有一天，他家里破产，他的父母只能依靠他的时候，他就不得不去改掉原来的坏毛病，想尽办法去赚钱。一个整天胡吃海喝身材走样的胖子，当被自己喜欢的女生拒绝，但女生告诉他如果他减肥成功，就答应和他在一起，这男的一定会拼了老命去减肥。</p>
<p><label style="color:blue">然而这个过程，一定是痛苦的。</label></p>
<h3 id="《教父》—成长之路不易且痛苦"><a href="#《教父》—成长之路不易且痛苦" class="headerlink" title="《教父》—成长之路不易且痛苦"></a>《教父》—成长之路不易且痛苦</h3><p>我个人最喜欢的电影，好好地看几遍并且看懂，相信你一定会蜕变成另一个人。</p>
<p><img src="/2020/07/11/%E6%94%B9%E5%8F%98%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%A5%BD%E4%BA%8B/v2-efb974d107f19d702e10a4b3a6a79169_b.jpg" alt="v2-efb974d107f19d702e10a4b3a6a79169_b"></p>
<p>这部电影的主题是黑帮，老教父叫维托柯里昂，是个黑帮老大，他有三个儿子，一个大儿子桑尼，脾气暴躁，二儿子弗雷多，性格懦弱，最小的儿子迈克尔，上过大学，当过兵，不想插手父亲黑帮中的事，只想跟女朋友过安稳的生活。在第一部中，老教父中了枪，躺在医院昏迷不醒，医院中保护他的人被被收买的警察赶走，最后是三儿子站出来老教父才保住了命。最后大儿子因为冲动被人算计用枪活活扫死，二儿子懦弱没有担当，当老教父退下时，迈克尔不得不站出来，不然整个家族的人都有危险。他失去了原来渴望的平静生活，他不被妻子理解最后不得不分开，在电影中（小说好像不同），女儿最后也因为黑帮的纠纷被人杀害。</p>
<p>影片的结尾，迈克尔独自一人在西西里院子的椅子上死去。看完教父三部曲后，你能明白很多为人处世的道理，也能学会如何以一个男人的方式去正确的处理事情，它不仅仅是黑帮片，你能从中看到成长和孤独，看到痛苦和责任。迈克尔走上这条路，表面上被迫的，换个角度看，其实是主动的背负起了整个家族的责任。</p>
<p><img src="/2020/07/11/%E6%94%B9%E5%8F%98%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%A5%BD%E4%BA%8B/image-20200712151612512.png" alt="image-20200712151612512"></p>
<h2 id="生于忧患，死于安乐"><a href="#生于忧患，死于安乐" class="headerlink" title="生于忧患，死于安乐"></a>生于忧患，死于安乐</h2><p>我今天要说的重点，其实不是要强调成长是被迫的，相反，我觉得<label style="color:blue">与其被动的在痛苦中成长，不如主动的做出改变。</label></p>
<p>我不知道你们身边有没有这样的人，家庭条件也一般，但整天无所事事，不是玩游戏就是睡觉，一点上进心没有，没有危机感也没有紧迫感，反正过一天算一天，这个世界上所有的事情好像都跟他无关。</p>
<h3 id="这个时代的年轻人，本该尝过生活的苦，但他们的父母，替他们扛下了所有"><a href="#这个时代的年轻人，本该尝过生活的苦，但他们的父母，替他们扛下了所有" class="headerlink" title="这个时代的年轻人，本该尝过生活的苦，但他们的父母，替他们扛下了所有"></a>这个时代的年轻人，本该尝过生活的苦，但他们的父母，替他们扛下了所有</h3><p>有多少无忧无虑年轻人的生活，是父母的汗水和鲜血换来的。当你还在嫌弃菜不好吃的时候，有想过父母吃着隔夜的饭菜吗；当你身穿名牌跟别人攀比的时候，有想过父母那多少年没有换过的鞋子吗。</p>
<p>之前看到过这么一句话：如果你的父母每天还很辛苦，那么我们长大的意义又是什么？</p>
<p>小的时候渴望长大，憧憬当大人的自由，现在长大了，能抽烟喝酒，能去网吧开黑，但这真的是长大的意义吗？长大是主动的背负起责任，是让那些在你小的时候，保护你的人，现在被你保护。</p>
<h3 id="你要被需要"><a href="#你要被需要" class="headerlink" title="你要被需要"></a>你要被需要</h3><p>不要总是当那个需要别人的人。</p>
<p>有的时候我会想，当自己的家人亲戚朋友遇到困难的时候，如果自己能够站出来那该多好，当自己有能力了，能被人坚定的相信和需要了，那是件多么幸福的事情。想一想未来自己的父母都已老去，当他们需要你的时候，你能不能成为他们坚强的依靠。</p>
<p><label style="color:blue">所以主动去改变自己吧，把责任和被人需要的感觉当成自己前行的动力。</label></p>
<h2 id="活在未来，而不是活在当下"><a href="#活在未来，而不是活在当下" class="headerlink" title="活在未来，而不是活在当下"></a>活在未来，而不是活在当下</h2><p>你要相信，优秀的人一定是活在未来，而不是活下当下，及时行乐。活在未来是一种思维，这样的人是有远见的人，他们不会痴迷于现状的美好，而是敢于去预测未来的不确定，为此做好准备。</p>
<p>或许很多人现在过着小康生活，日子安稳幸福，但你要明白，<label style="color:blue">所有的事情不会像你想的那样一成不变</label>，人活着一定要有一点危机感，这样才能进步。</p>
<p>当生活突如其来的给你来一场灾难，如果你没做好准备，那么你会被伤得体无完肤。也许这时你会说，这不是你所说的被迫成长吗？</p>
<p>没错，每个人都会经历这样的成长，但我说过，这个过程是十分痛苦的，你本可以减轻伤害，甚至避免，只要你之前主动做出过改变。</p>
<p>这就是主动去改变、活在未来的重要性，你只有越优秀，你的铠甲才会越厚，而不是受到伤害后，才意识到自己薄弱的身躯。</p>
<p>你可能会说，到头来，你这他妈还不是一篇狗血鸡汤吗？你可以这么认为，但我没说过这个世界很美好，也没说过成长很幸福，我告诉你的是，成长必定是痛苦的，你可能会疼死，但你可以打预防针或者吃止痛药。</p>
<p>这不是鸡汤，这是哲学和智慧。</p>
<p>我特别喜欢英雄联盟，其中一些人物有许多富含哲理的话：改变，就是好事。—卡兹克</p>
<p><img src="/2020/07/11/%E6%94%B9%E5%8F%98%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%A5%BD%E4%BA%8B/image-20200712155832581.png" alt="image-20200712155832581"></p>
<p>——————持续更新中</p>
]]></content>
      <categories>
        <category>人生啊</category>
      </categories>
      <tags>
        <tag>人生啊</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊Java这条路该怎么走</title>
    <url>/2020/07/09/%E8%81%8A%E4%B8%80%E8%81%8AJava%E8%BF%99%E6%9D%A1%E8%B7%AF%E8%AF%A5%E6%80%8E%E4%B9%88%E8%B5%B0/</url>
    <content><![CDATA[<p>网上有很多关于Java学习路线的帖子，有些列了很长的思维导图，看着很费劲也看不明白，还有一些讲得太深，对于初学者来说不太友好。今天我从零开始给大家讲讲从起步到工作需要哪些技术，这些技术大概是做什么的。文章有点长，如果耐心看完，相信对你今后的学习规划和进度会有很大的帮助。</p>
<p><img src="/2020/07/09/%E8%81%8A%E4%B8%80%E8%81%8AJava%E8%BF%99%E6%9D%A1%E8%B7%AF%E8%AF%A5%E6%80%8E%E4%B9%88%E8%B5%B0/image-20200709143657327.png" alt="image-20200709143657327"></p>
<a id="more"></a>

<h2 id="Java开发到底是做什么"><a href="#Java开发到底是做什么" class="headerlink" title="Java开发到底是做什么"></a>Java开发到底是做什么</h2><p>就目前来讲，基于Java开发一共有两条路可走，第一条路就是安卓开发，有人说现在安卓就业不太友好，因为现在App太多，好像谁都能做一样，所以竞争很激烈，一个产品想要面向市场做的很好，难度非常大，另一种说法就是对立了，因为现在智能手机的普及，人们对于App的需求也变高了，所以这算是优势。</p>
<p>但Java最主要的开发方向，就是基于Web开发，也就是我们所说的网页后台开发。Java在这个行业有着天然的优势，高并发性能好，开源项目生态好，所有的大型网站，像淘宝、京东这些大型电商网站，不可能用其他语言作为后台语言，虽然Python、PHP也能做，但是网站一旦做大了，它们根本没法稳定的运行。淘宝最开始是用的PHP，但是随着用的人越来越多，最后他们把整个项目换成了Java。</p>
<p>顺带提一下桌面应用开发，想要做这个行业的小伙伴我可以直接劝退了，因为Java不适合做桌面应用程序的开发，虽然Java可以用awt、swing设计图形界面，但是性能太低而且可以移植性也差，基本已经凉凉了。所以想要做游戏或者其他的桌面程序的小伙伴们可以去学C#，也是非常香的。</p>
<p>下面简单的用导图列出了整个学习的路线，具体的内容将在文章中详细介绍。</p>
<p><img src="/2020/07/09/%E8%81%8A%E4%B8%80%E8%81%8AJava%E8%BF%99%E6%9D%A1%E8%B7%AF%E8%AF%A5%E6%80%8E%E4%B9%88%E8%B5%B0/image-20200709205248022.png" alt="image-20200709205248022"></p>
<h2 id="阶段一：JavaSE"><a href="#阶段一：JavaSE" class="headerlink" title="阶段一：JavaSE"></a>阶段一：JavaSE</h2><p>JavaSE就是Java Standard Edition，Java标准版本，这个阶段我们学的就是Java的语法还有Java的特性，很多人对于学Java有误解，认为学Java就是学的JavaSE，这是很天真的想法，这个阶段的学习专业点的术语叫做MAS（Minimum action step）最小行动步骤，什么意思呢？就是如果你只学了JavaSE，那么你什么都干不了，如果你不学，那么后面的技术你同样也学不了。所以这个阶段的学习十分重要，就是打地基，你学的越扎实，后面越轻松。</p>
<p>还有一点要提的是：我建议在开始学Java之前，最好学一下C语言。Java其实跟C语言非常像，因为Java就是用C和C++写的，但是摈弃了C和C++中一些不安全的操作和进行了优化改进，学完C语言后能和Java进行无缝对接，而且很多知识点在C语言出现过的，可以一带而过，so easy too happy。这里我推荐郝斌老师的C语言教程，我对郝斌老师的感情可以说是非常深了，因为最开始入这个门就是看他的视频，讲得通俗易懂而且还很幽默，完全不会因为代码的枯燥而无聊，反正无脑吹就对了。他有C和Java的教学视频，当然还有数据结构和Sql Server的视频，我当初看完C立马接着看他的Java视频了，连接非常顺畅。但是这里我还是推荐看其他新一点的视频，因为郝斌老师的视频是09年录的，稍稍有点老了，推荐动力节点的Java教程，比较新而且非常非常非常全，老师也是非常不错。（这些视频b站上都能直接搜到，完全免费还带资料。下面所有的技术你都能在b站上找到很好教程，外面几万块的课全部免费，我的大学基本就是在b站读的….）</p>
<h2 id="阶段二：MySql和JDBC"><a href="#阶段二：MySql和JDBC" class="headerlink" title="阶段二：MySql和JDBC"></a>阶段二：MySql和JDBC</h2><h3 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h3><p>Mysql就是数据库的一种，这个阶段的学习也是非常非常重要，是难点也是重点。现在的软件开发行业，不管你学的什么语言，你不学数据库，你根本做不了开发，为什么这么说，因为只要你是做程序开发的，必定离不开对数据的操作，比方说，你进入一个网站或者一个app，你肯定要注册登录吧，那么你的账号密码就要存储吧，不然你下次怎么登陆呢？那么怎么存呢？存在程序里吗？第一你存不了这么多数据，你的ROM就这么点大还这么贵，就算你能存吧，你这程序一停止，或者你电脑一关机，你的数据就没了。你用Excel存吗？一个平台的人数这么多，就算你能存吧，你打开这个文件不知道要多久，况且这么多数据查找非常慢，所以你就需要数据库，它其实就是一个类似于Excel的东西，只不过存储性能极高，能存储千万级数据，查找数据极快，现阶段的学习主要学的是对数据的增删改查，包括你以后在公司里做的，八九也就是增删改查，重点也就是查。但你要进阶的往下学，底层的东西和高级部分就有点难了，推荐在学完整个基础后，回过头来好好学学原理。</p>
<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>JDBC（Java Database Connectivity），Java数据库连接，简单来讲就是如何用Java去操作数据库，这算是一个小小的技术，学起来非常快，但很实用，它将会伴随你整个开发生涯。</p>
<h2 id="阶段三：网页前端技术"><a href="#阶段三：网页前端技术" class="headerlink" title="阶段三：网页前端技术"></a>阶段三：网页前端技术</h2><h3 id="什么是前端和后端？"><a href="#什么是前端和后端？" class="headerlink" title="什么是前端和后端？"></a>什么是前端和后端？</h3><p>相信很多小伙伴都有听说过前端和后端，但不是很了解，这里我给大家简单的说下什么是前端什么是后端。</p>
<p>前端技术就是你所能看到的东西，例如一个网页有背景，有列表分类，有搜索框，这些东西就是前端要写的东西，而后端就是你点击搜索后，会呈现你想要搜索的内容，它后台是怎么查找的你看不到，你在页面上只能看到结果，我们做Java开发，主要就是对于后台功能的实现。</p>
<h4 id="为啥要学前端？"><a href="#为啥要学前端？" class="headerlink" title="为啥要学前端？"></a>为啥要学前端？</h4><p>那么问题来了，我们学后端的人，为啥要学前端呢？刚开始也我很苦恼，心想，这种东西难道公司里没有什么学设计的小姐姐去搞吗？我凭什么要把页面做的这么好看，我只要把功能写出来就行了啊。但事实是，你一开始去的公司，很可能是小公司，公司为了节省成本和人力，你基本上要把前后端的活全包了，这样公司能少发一个人的工资。当然你进了大厂，那么基本上公司里的项目都是前后端分离的，你不用关心前端的代码，你只要写好你的功能就行了。所以保险起见，我建议小伙伴们还是要好好学前端，我看了很多公司的招聘，他们都是要求会前端的，他们的要求里写的很明白，会前端框架的优先考虑，所以这绝对是加分项了（我现在就很后悔我前端没好好学）。当然学习前端也不仅仅是这个原因，因为我们在写后台的时候，总会去前端去取数据，那么如果你前端一窍不通，你压根就没法操作，你不知道这个数据是怎么传过来的，也不知道怎么把数据回传给前端页面，所以前端可以不学精，但一定要学，或多或少会一点即可。</p>
<h3 id="前端的三门主要技术"><a href="#前端的三门主要技术" class="headerlink" title="前端的三门主要技术"></a>前端的三门主要技术</h3><h4 id="HTML-amp-CSS-amp-JavaScript"><a href="#HTML-amp-CSS-amp-JavaScript" class="headerlink" title="HTML&amp;CSS&amp;JavaScript"></a>HTML&amp;CSS&amp;JavaScript</h4><p>简单的介绍一下这三门技术：HTML就是网页的骨架，就好比建房子时，整个的框架，CSS就是如何把网页装饰的很漂亮，好比房子的装修，而JavaScript就是让这个网页”动”起来，好比你房子的各种智能家居，你不用手动拉窗帘，你可以用手机去控制窗帘的开关。</p>
<p>另外，这三门技术都是脚本语言，就是不用编译就能运行，只要你有浏览器就行，你代码语法错误它也照常能运行，属于弱类型的语言。还有一点就是JavaScript，很多人有误解，认为它跟Java有什么关系，实际上压根就没关系，如果非要说有关系，那么就是它的语法跟Java很像而已（它原来不叫JavaScript，后来改成这个就是为了蹭Java的热度）。</p>
<h5 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h5><p>Jquery就是一个JavaScript的类库，能更方便的使用一些函数，它对JavaScript进行了简单的封装，能很方便对各种元素进行操作。</p>
<h2 id="阶段四：JavaWeb"><a href="#阶段四：JavaWeb" class="headerlink" title="阶段四：JavaWeb"></a>阶段四：JavaWeb</h2><p>学到这里，那么恭喜你，你已经可以完成一个网站的一些基本功能了，在2000年左右的时候已经能找到一份不错的工作了。但是技术升级得非常快，如今停留在这个阶段，工作是远远不够的。</p>
<p>这个阶段的学习，就是学习如何将前后端交互，完成一个功能。这里综合了你前面所有学习到技术，你将会用到数据库去验证账号密码是否正确，你将会从数据库取到数据传递给前端页面显示，你也能够完成一个账号密码真正意义上的修改（从网页修改数据库中的数据）。所以你不难发现，你这些功能永远都在跟数据库打交道，这也是我在前面讲的，为什么数据库这么重要的原因。</p>
<p>除此之外，你还能学习很多新的小技术，例如没有登录之前，无法进入指定的页面（Filter过滤器，Session会话），记住账号密码（Cookie），还有文件上传和邮件发送等功能。</p>
<p>但是这个阶段的学习你一定是痛苦的（至少我是很痛苦的），第一：代码量非常多。第二：有很多莫名其妙的bug（各种疑难杂症，非常搞心态）。</p>
<h2 id="阶段五：SSM框架"><a href="#阶段五：SSM框架" class="headerlink" title="阶段五：SSM框架"></a>阶段五：SSM框架</h2><p>上一阶段的学习中，你会发现代码非常繁琐，而且有大量的重复代码，另外数据库的查询语句写起来也是十分麻烦。这个阶段的学习你将会翻开崭新的一页：Spring框架（顾名思义，你的春天来临了）。框架就是在原来JavaWeb的基础上，对一些代码进行封装，你原来要写十几行的代码，现在一行就搞定了。那么你可能会疑惑，我直接学SSM不行吗，答案是：可以。我们之所以要学JavaWeb是因为它是底层基础的东西，你只有知道JavaWeb有多麻烦，才知道SSM存在的意义。</p>
<p>SSM是三个框架的首字母缩写，对应的是Spring，SpringMVC，Mybatis，每一个框架都对原来JavaWeb阶段的MVC三层架构进行了更简便的操作，SpringMVC对应视图层（控制请求，传递数据），Spring对应业务层（处理业务），Mybatis对应持久层（操作数据库）。这里听不懂也没有关系，当你学到这里的时候，自然会明白。</p>
<p>学完SSM后一基本上可以在公司干点活儿啦，因为现在很多公司的项目都在用SSM，但如果想要进更好的公司，你还要继续学习。</p>
<h2 id="阶段六：SpringBoot-VUE"><a href="#阶段六：SpringBoot-VUE" class="headerlink" title="阶段六：SpringBoot+VUE"></a>阶段六：SpringBoot+VUE</h2><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>当偷懒的程序员们对代码封装开发了SSM框架后，发现还不够偷懒，因为配置文件是在是太多了，所以又开始研发新的框架（人类的懒惰是会让技术进步的），于是新的框架又产生了：SpringBoot。简单来讲，SpringBoot就是在原先SSM框架上又进行了一次封装，省去了很多配置文件。</p>
<h3 id="Duubo-Zookeeper"><a href="#Duubo-Zookeeper" class="headerlink" title="Duubo+Zookeeper"></a>Duubo+Zookeeper</h3><p>在SpringBoot的学习中你将会学到这两项技术，它们是基于分布式系统提出的方案，也叫微服务。</p>
<h3 id="VUE（真正实现了前后端分离）"><a href="#VUE（真正实现了前后端分离）" class="headerlink" title="VUE（真正实现了前后端分离）"></a>VUE（真正实现了前后端分离）</h3><p>这里又出现了前端的东西，VUE是一个前端的框架，在如今的前后端分离时代，前端只管写前端页面，后端只用提供接口就行，现在很多公司都要求后端开发会VUE（真是太难了）。</p>
<p>当你完成这一阶段的学习，你已经能去一些中型的公司啦，稍微找一家好点公司，月薪7k+应该问题不大。这时候你也成为了一个合格码农，但是码农其实是很低级的，对于聪明的你，应该有更高的追求。</p>
<h2 id="阶段七：微服务"><a href="#阶段七：微服务" class="headerlink" title="阶段七：微服务"></a>阶段七：微服务</h2><h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><p>SpringCloud算是这几年的Web开发的潮流和趋势，它是基于分布式系统提出的一套完善的方案。你可以理解成有很多个SpringBoot的项目结合在一起，然后SpringCloud就是用来统一维护和管理这些项目(模块化)。大型公司都在用，但是小公司因为业务小的可怜，所以基本上也用不到，但这个技术一定是未来的趋势。学就完事了。</p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>Git入门非常快，几个小时就搞定了，它主要是用来管理项目和团队开发的，这个在工作之前最好学一下。</p>
<h2 id="阶段八：扩展和完善"><a href="#阶段八：扩展和完善" class="headerlink" title="阶段八：扩展和完善"></a>阶段八：扩展和完善</h2><p>当你完成上面七个阶段的学习，你可能会觉得你已经无敌了，你可能长叹一口气，心想，终于结束了，我当初也是这么想的，但后来才发现，原来所谓的结束，其实是另一轮更高难度关卡的开始······</p>
<h3 id="等待你的，是更多你不知道的东西"><a href="#等待你的，是更多你不知道的东西" class="headerlink" title="等待你的，是更多你不知道的东西"></a>等待你的，是更多你不知道的东西</h3><p>1、Linux（你的项目会放在上面运行）</p>
<p>2、JVM（大厂面试高频）</p>
<p>3、Redis（nosql数据库）</p>
<p>4、RocketMQ\RabbitMQ（消息队列）</p>
<p>5、Docker（集装箱）</p>
<p>6、Mycat（数据库中间件）</p>
<p>7、设计模式（很重要）</p>
<p>等等····</p>
<p>想要成为真正的程序员，你一定要会的两个东西：数据结构+算法，大厂非常喜欢算法好的童鞋。除此之外，你还要回过头来探究各种源码，JDK源码、Spring源码，SpringBoot源码，数据库底层原理，等等等等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先感谢你能耐心的看到这里。</p>
<p>必须得承认的是，这条路确实不好走，但是别人也不好走，80%的人在中间的时候就放弃了，最后剩下的人寥寥无几。有些人在JavaSE的时候就已经放弃了，因为发现自己压根不适合敲代码；有些人在学前端的时候发现前端更有意思可能转前端了；有些人在JavaWeb时候因为太难bug太多也放弃了，能坚持到最后的人又有多少呢，所以不要恐惧，如果你真的想做这一行，趁年轻试一试，万一成功了呢。另外，如果你跟我一样，对代码是感兴趣的，一定要保持这颗初心，不要气馁和烦躁，当觉得自己快坚持不下去的时候，回过头来想想以前的初衷，调整状态，继续前进。</p>
<p>祝各位早日年入百万。</p>
<p>——————持续更新中                                                                                                                    </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>学习路线</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例模式</title>
    <url>/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200713193236863.png" alt="image-20200713193236863"></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>我们都知道在Java中可以new出一个或者多个对象实例，而所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<label style="color:red">只能存在一个对象实例</label>，并且该类只提供一个取得其对象实例的<label style="color:red">静态方法</label>  。</p>
<a id="more"></a>

<h3 id="单例模式使用场景"><a href="#单例模式使用场景" class="headerlink" title="单例模式使用场景"></a>单例模式使用场景</h3><p>1、需要频繁的创建和销毁的对象</p>
<p>2、创建对象时耗费资源或时间过多（即重量级对象）</p>
<p>3、经常要用到的对象： 工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等)  </p>
<h3 id="介绍小结"><a href="#介绍小结" class="headerlink" title="介绍小结"></a>介绍小结</h3><p>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能 ；当想实例化一个单例类的时候，必须要使用相应的获取对象的方法，而不是使用new 。 </p>
<h2 id="单例模式的代码实现方式"><a href="#单例模式的代码实现方式" class="headerlink" title="单例模式的代码实现方式"></a>单例模式的代码实现方式</h2><p>单例模式一共有八种实现方式：</p>
<p><label style="color:red">1)饿汉式(静态常量) </label></p>
<p><label style="color:red">2)饿汉式（静态代码块）  </label></p>
<p>3)懒汉式(线程不安全) </p>
<p>4)懒汉式(线程安全，同步方法) </p>
<p>5)懒汉式(同步代码块)  </p>
<p><label style="color:red">6)双重检查  </label></p>
<p><label style="color:red">7)静态内部类  </label></p>
<p><label style="color:red">8)枚举  </label></p>
<p>tip:标红的是推荐使用，黑色表示能实现但是不推荐使用</p>
<h3 id="（1）饿汉式（静态常量）"><a href="#（1）饿汉式（静态常量）" class="headerlink" title="（1）饿汉式（静态常量）"></a>（1）饿汉式（静态常量）</h3><p>基本步骤：构造器私有化（防止new）—–&gt;在类的内部创建对象—–&gt;对外提供一个获得对象实例的方法（getInstance）</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">		System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对外提供方法获得对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点分析：</p>
<p>优点：写法简单，在类加载的时候完成初始化，避免了线程同步的问题。</p>
<p>缺点：因为是在类加载的时候完成初始化，没有达到<label style="color:red">懒加载的效果</label>，如果从始至终都没有使用这个实例，会造成内存的浪费。</p>
<p>总结：  这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用  getInstance方法，但是导致类装载的原因有很多种，例如类的其他方法被调用等，因此不能确定有其他的方式（其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading（懒加载）的效果  。</p>
<h3 id="（2）饿汉式（静态代码块）"><a href="#（2）饿汉式（静态代码块）" class="headerlink" title="（2）饿汉式（静态代码块）"></a>（2）饿汉式（静态代码块）</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</p>
<p><label style="color:red"> 结论：这种单例模式可用，但是可能造成内存浪费。</label></p>
<h3 id="（3）懒汉式（线程不安全）"><a href="#（3）懒汉式（线程不安全）" class="headerlink" title="（3）懒汉式（线程不安全）"></a>（3）懒汉式（线程不安全）</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建instance  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点分析：</p>
<p>优点：只有在用到的时候才去创建实例，起到了懒加载的效果。</p>
<p>缺点：<label style="color:red">线程不安全。</label>  在多线程下，如果一个线程进入了 if (singleton  == null)判断语句块，还未来得及往下执行，另一个线程也进入了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式 。</p>
<p><label style="color:red">结论：在实际开发中，不要使用这种方式。</label></p>
<h3 id="（4）懒汉式（线程安全，同步方法）"><a href="#（4）懒汉式（线程安全，同步方法）" class="headerlink" title="（4）懒汉式（线程安全，同步方法）"></a>（4）懒汉式（线程安全，同步方法）</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<p>优点：解决了线程安全的问题</p>
<p>缺点：效率太低，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return就行了。</p>
<p><label style="color:red">结论：在实际开发中，不推荐使用这种方式  </label></p>
<h3 id="（5）懒汉式（同步代码块）"><a href="#（5）懒汉式（同步代码块）" class="headerlink" title="（5）懒汉式（同步代码块）"></a>（5）懒汉式（同步代码块）</h3><p>提示：这种方法不能达到线程安全安全的目的，它是为了解决上一种方法效率太低的问题，所以把synchronized后置到判断条件上，之所以要提这种方式是为了引出下一种同时解决效率问题且线程安全的方法。（这种方法大家看看就行）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//执行到这里的时候，还是有可能转到另一个线程中执行，所以没有解决线程安全问题</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：<label style="color:red">这种方式不要在开发中使用！</label></p>
<h3 id="（6）双重检查（效率高，线程安全）"><a href="#（6）双重检查（效率高，线程安全）" class="headerlink" title="（6）双重检查（效率高，线程安全）"></a>（6）双重检查（效率高，线程安全）</h3><p>前两种方法都有问题，于是设计这种方法结合了上面两种方法的优点，第一效率高，第二线程安全。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//volatile关键字是一个轻量级的synchronized，它可以保证instance在内存中读取到的值是最新的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一次检查</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">               	<span class="comment">//第二次检查</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>（1）<label style="color:red">Double-Check（双重检查）</label>概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton  == null)检查，这样就可以保证线程安全了。  </p>
<p>（2)这样设计，实例化代码只用执行一次，后面再次访问时，判断if (singleton  == null)如果为false，直接 return实例化对象，也避免了反复进行方法同步。</p>
<p>结论：<label style="color:red">  线程安全；延迟加载；效率较高。在实际开发中，推荐使用这种单例设计模式 。</label></p>
<h3 id="（7）静态内部类"><a href="#（7）静态内部类" class="headerlink" title="（7）静态内部类"></a>（7）静态内部类</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写一个静态内部类,该类中有一个静态属性Singleton</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>（1）这种方式采用了类装载的机制来保证初始化实例时只有一个线程：</p>
<p><span class="github-emoji" alias="bulb" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8">&#x1f4a1;</span>静态内部类SingletonInstance在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成 Singleton的实例化。(妙啊<span class="github-emoji" alias="smiley" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8">&#x1f603;</span>）</p>
<p><span class="github-emoji" alias="bulb" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8">&#x1f4a1;</span>tip:  类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p>
<p>（2）结论：</p>
<p><label style="color:red">  避免了线程不安全，利用静态内部类特点实现延迟加载，效率高，推荐使用</label></p>
<h3 id="（8）枚举"><a href="#（8）枚举" class="headerlink" title="（8）枚举"></a>（8）枚举</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.INSTANCE();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就没了？？？ 是的这就没了。是不是so easy。</p>
<h4 id="补充：枚举类"><a href="#补充：枚举类" class="headerlink" title="补充：枚举类"></a>补充：枚举类</h4><p>JDK1.5中新增的枚举特性（没学过的小伙伴去巩固一下Java基础，这里不多说了，就简单的介绍一下）。枚举类是天然单例，是真正的final类，客户端不允许创建枚举类的实例，所以它是个单例。</p>
<p>那使用枚举类有啥好处呢？接下来你可能心里有一万个mmp。</p>
<p>我们在前面实现单例模式的时候，都把构造器私有化，这样可以防止客户端创建对象，那么构造器私有化真的能防止new出对象吗，我们来看下面的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获得反射CLASS对象</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">"singleton.test.Singleton"</span>);</span><br><span class="line">        <span class="comment">//获得构造器</span></span><br><span class="line">        Constructor constructor = c1.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//这个方法的参数设为true时，就会抑制Java的语法检查，它可以通过反射获得类的私有属性和私有方法（包括构造方法）</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Singleton instance = (Singleton) constructor.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Singleton对象在外部被创建了！！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供方法获得对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200713184811418.png" alt="image-20200713184811418"></p>
<p>What？？原来之前构造器私有化并不能防止new对象！（学过反射的同学应该知道，所以Java基础非常重要）</p>
<p><img src="/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200713190735455.png" alt="image-20200713190735455"></p>
<p>这就是为什么要使用过枚举实现单例模式的原因，它可以防御反射攻击与序列化和反序列化破坏，这种方式是Effective Java作者Josh Bloch提倡的方式 ，所以这种方式是单例模式的<label style="color:red">最佳实现方式。</label></p>
<p>结论：<label style="color:red">十分简单，极力推荐</label></p>
<h2 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h2><p>（1）JDK中，java.lang.Runtime就是经典的单例模式(饿汉式)。</p>
<p>源码如下：</p>
<p><img src="/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200713191014293.png" alt="image-20200713191014293"></p>
<p>（2）同样，在Spring中的bean的scope为singleton时，它也是很经典的单例模式，有兴趣的同学可以去研究下源码。</p>
<p>到此为止，单例设计就结束了，感谢您的阅读。</p>
<p><img src="/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200713191900364.png" alt="image-20200713191900364"></p>
<p>——————设计模式持续更新中。</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>单例模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
